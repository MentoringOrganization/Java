# 💡 (6주차) 자바 예상 질문 정리

# 📜 이전 복습

## [자바의 신] 27장

## 1. Serializable 인터페이스란?

우선 Serializable이란 직역하자면 **직렬화**이다.

우리는 개발 도중 생성한 객체를 파일로 저장하거나, 저장한 객체를 읽을 일이 발생할 수 있다. 그리고 다른 객체를 다른 서버로 보내거나 다른 서버에서 생성한 객체를 받을 일도 있을 수도 있다. 이때, 사용하는 것이 Serializabel 인터페이스이다.

위의 말을 전문적으로 설명하자면, 객체의 상태를 바이트 스트림(컴퓨터가 이해할 수 있는 저수준의 이진 데이터 형식)으로 변환하여 파일에 저장하거나 네트워크를 통해 전송할 수 있게 하는 것이 **객체의 직렬화**이다.
- 이때, 객체의 데이터는 객체의 멤버 변수들에 저장된 값을 의미한다. (ex. 사람 객체 -> 사람 객체의 데이터는 이름, 나이, 주소 등)

Serializable은 구현해야 할 메소드가 존재하지 않는 특별한 인터페이스이지만, 객체의 상태를 유지하고 재사용하기 위한 중요한 기능이다.
- 직렬화 시 ObjectOuputStream을, 역직렬화시 ObjectInputStream을 사용한다.

> Serializable 인터페이스를 구현하는 간단한 예시

```
import java.io.Serializable;

public class Employee implements Serializable {
    private String name;
    private int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // getters and setters
}
```

### NIO에서 버퍼의 대표적인 3가지 메소드에 대해 설명해보자

- capacity() : 버퍼에 담을 수 있는 크기 리턴
- limit() : 버퍼에서 읽거나 쓸 수 없는 첫 위지 리턴 
- position() : 현재 버퍼의 위치 리턴

위 3개 메소드를 통해 구한 값의 관계는 다음과 같다.

``
0 <= position <= limit <= 크기(capacity)
``

## [자바의 신] 28장

## 2. 자바에서는 대표적인 OSI 7 layer들에 TCP 통신을 한다. 이때, OSI 7 layer란?
- https://lxxyeon.tistory.com/155
- https://velog.io/@cgotjh/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-OSI-7-%EA%B3%84%EC%B8%B5-OSI-7-LAYER-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90-%EA%B0%81-%EA%B3%84%EC%B8%B5-%EC%84%A4%EB%AA%85
- 수제비 정보처리기사 실기책(2022)
- chatGPT(유료)

OSI 7 계층은 네트크 통신이 일어나는 과정을 7단계로 나눈 국제 표준화 기구(ISO)에서 정의한 네트워크 표준 모델이다.

총 1단계 ~ 7단계로 구성되어 있으며 발신 측은 각 계층을 지날 때마다 Header(헤더; 해당 계층의 기능과 관련된 제어 정보)가 붙게 되고 수신 측은 역순으로 헤더를 분석하게 된다.
- 각 계층은 독립적으로 작동하고 각 계층은 하위 계층의 기능을 이용하여 상위 계층에 기능을 제공한다.
  - 따라서 네트워크 통신의 복잡성이 감소하고 문제 발생 시 해당 계층만을 집중적으로 분석하여 문제를 해결할 수 있다.

![image](https://user-images.githubusercontent.com/103405457/237029018-cc6a8d67-7019-4f18-ace1-18ea95140de3.png)

### 1계층 Physical Layer(물리 계층)
전기 신호, 광 신호, 무선 신호 등의 형태로 물리적 매체를 통한 데이터를 전송하는 계층이다.

이때, 전기적인 신호(0,1)로 변환해서 주고 받는 기능만 수행한다.
- 통신 단위 : 비트(Bit; 0과 1로 표현되며 Off, On 상태로 표현 가능)
- 통신 장비 : 통신 케이블, 리피터, 허브

### 2계층 DataLink Layer(데이터링크 계층)
인접 시스템(네트워크 장치) 간 데이터 전송과 전송 오류를 제어하는 계층이다.

브리지나 스위치를 통해 프레임에 물리적 주소(MAC address)를 부여하고 에러 검출, 재전송, 흐름 제어, 회선 제어를 수행한다.
- 전송 단위 : 프레임(Frame)
- 통신 장비 : 브리지, 스위치, 이더넷 등

### 3계층 Network Layer(네트워크 계층)
서로 다른 네트워크 간의 데이터 전송을 담당하며 가장 안전하고 빠르게 데이터를 보내기 위해 최적의 경로를 설정하는 계층이다.

라우터를 통해 경로를 선택하고 주소(IP)를 정한 뒤 경로(Route)에 따라 패킷을 전달하며 IP 헤더가 추가된다.
- 프로토콜 : IP/ICMP
- 전송 단위 : 패킷(Packet)
- 전송 장비 : 라우터

### 4계층 Transport Layer(전송 계층)
송수신, 즉 프로세스 간의 연결을 담당하며 신뢰성 있는 데이터를 전송하여 통신을 보장하는 계층이다.

이때, 오류 검출 및 복구, 흐름제어와 중복 검사 등을 수행하며 데이터 전송을 위해 포트(Port) 번호를 사용한다.
- 프로토콜 : TCP/UDP
- 전송 단위 : 세그먼트(Segment)
- 전송 장비 : L4 스위치

### 5계층 Session Layer(세션 계층)
송수신 간의 논리적인 연결, 즉 네트워크 상에서 컴퓨터 간의 연결(세션)을 관리하는 계층이다.

통신 세션을 설정, 유지, 종료하는 연결 접속 및 동기 제어를 담당한다.
- 전송 단위 : 데이터(Data)
- 전송 장비 : 호스트(PC 등)

### 6계층 Presentation Layer(표현 계층)
데이터 형식 설정과 부호 교환, 그리고 암/복호화를 담당하는 계층이다.
- 데이터를 애플리케이션이 이해할 수 있는 형식으로 변환(인코딩, 디코딩)하거나 데이터를 암호화/복호화하는 역할을 수행한다.
- 프로토콜 : JPEG, MPEG

### 7계층 Application Layer(응용 계층)
사용자와 네트워크 간 응용 서비스 연결 및 데이터 생성을 담당한다.
- 이메일, 웹 브라우저 등의 애플리케이션 등이 이 계층에서 작동한다.
- 프로토콜 : HTTTP, FTP

---

그러나 현재는 OSI 7 Layer보다 TCP/IP 4 Layer를 더 많이 활용하는 추세이다.

![image](https://user-images.githubusercontent.com/103405457/237029292-f612319d-a382-4e29-8283-ccb51c18f6b7.png)

## 3. Socket 클래스란?

자바에서 TCP 통신을 수행하기 위해서 Socket 클래스를 사용한다.

Socket 클래스는 데이터를 보내는 쪽(보통 클라이언트)에서 **Socket 객체를 직접 생성**하여 사용한다. 또한 데이터를 받는 쪽(보통 서버)에서 클라이언트 요청을 받으면, 요청에 대한 Socket 객체를 생성하여 처리한다.
- 즉, Socket 클래스는 클라이언트 쪽이든 서버 쪽이든 원격에 있는 장비와의 연결 상태를 보관하고 있다.

좀 더 자세히 살펴보자면, 위에서 말한 **서버에서 데이터를 받을 때**에는 ServerSocket이라는 클래스를 사용하여 데이터를 받는다.

즉, 서버에서 데이터를 받을 때에는 ServerSocket 클래스에서 제공하는 메소드에서 **클라이언트 요청이 생기면 Socket 객체를 생성**해서 전달한다.

## [자바의 신] 32장

## 4. Java 8 기준으로 람다식은 무엇인가?
먼저 자바에서 람다 표현식이란 메소드를 하나의 식으로 표현한 것으로, 메소드를 더 간결하게 표현하고 코드의 가독성을 높이기 위해 사용한다.

람다 표현식은 익명 클래스의 가독성이 떨어지는 단점을 보완하기 위해 만들어졌으며 이러한 익명 클래스와 람다 표현식은 상호 간에 전환이 가능하다. 또한 익명 함수도 람다 표현식을 사용하여 생성할 수 있다.
- 단, 람다 표현식은 인터페이스에 메소드가 하나인 것(= 함수형 인터페이스)들만 적용 가능하다.

**익명 클래스와 익명 함수**

두 개념 모두 이름이 없다는 공통점이 있지만, 익명 클래스는 주로 클래스 또는 인터페이스의 일부 메소드를 재정의할 때 사용되는 반면 익명 함수는 람다 표현식을 통해 함수형 인터페이스의 메소드를 구현할 때 사용한다.

> 람다 표현식을 적용한 Runnable 인터페이스
```
(int x, int y) -> x + y // 매개 변수 목록, 화살표 토근(Arrouw Token), 처리 식
() -> 43
(String s) -> { System.out.println(s); }
```

---

## JDK 8 기준으로 변경된 사항은?
- https://johngrib.github.io/wiki/java8-why-permgen-removed/
- https://seunghyunson.tistory.com/23

JDK 7 기준
> eden -> survivor0 -> survivor1 -> old -> permanent ->>

![image](https://user-images.githubusercontent.com/103405457/237050701-58bfd0f6-a8ee-477e-bff1-e5ec2944af60.png)

JDK 8 기준, JVM 구조에서 Method Area의 Permanent 영역이 없어졌다.
> eden -> survivor0 -> survivor1 -> old -> metaspace ->>

![image](https://user-images.githubusercontent.com/103405457/237050682-6d9d95d2-491d-4592-b1a1-5e2228808fe0.png)

기존의 Permanent 영역은 class, method meta 정보, static 변수와 상수 정보들이 저장되어 있는 공간이었다. 하지만 크기가 제한적이라 OutOfMemoryError를 유발한다는 단점이 존재했다.

이에 크기가 작기 때문에 JVM은 비용이 많이 드는 GC를 수시로 수행해 필요한 공간을 확보해야했고, 언로드 되지 않은 class loader들이 계속해서 새로운 클래스를 로드하여 memory leak(메모리 누수)이 발생하곤 했다.

이러한 문제들을 개선하기 위해 JDK 8부터 Permanet 영역은 Metaspace라는 영역으로 대체되었다.

Metaspace는 OS에서 제공하는 native 메모리를 사용하며, 필요 시 자동으로 크기를 증가시켜 공간을 확보하게 된다.

따라서 class meta data 사용량이 metaspace의 최대 크기게 도달할 때, 자동으로 GC가 수행되면서 OutOfMemoryError의 발생 확률을 줄일 수 있게 되었다.

## 5. 스트림은 무엇이며 구조는 어떻게 이뤄져있는가?

스트림(Stream)은 직역하자면 "개천, 시내, (액체/기체의) 줄기, (사람/차량들로 계속 이어진) 줄"로 해석된다.

Java 8에서 추가된 인터페이스로 데이터 처리 연산을 지원하고 연속적인 데이터를 다루는데 자주 사용되는 메소드들이 정의되어 있다.
- 이때, 연속적인 데이터로는 컬렉션과 stream() 메소드를 통해 변환한 Stream 객체가 있다.

> 스트림의 구조
```
list.stream().filter(x-> x>10).count() // 스트림 생성, 중간 연산, 종단 연산
```
**스트림 생성**

컬렉션의 목록을 스트림 객체로 변환한다. 이때 스트림 객체는 java.util.stream 패키지의 Stream 인터페이스를 일컫는다.
- 스트림 생성 시 stream() 메소드를 호출하여 Stream 타입을 리턴한다.
  - 이러한, stream()은 순차적으로 데이터를 처리한다.
   - ex. 10개의 데이터 중 0 ~ 9번째의 인덱스를 처음부터 하나씩 처리

**중간 연산**

생성된 스트림 객체를 사용하여 중간 연산 부분에서 처리한다. 하지만, 이 부분에서는 아무런 결과를 리턴하지 못하기에 intermeidate operation이라고 한다.
- 데이터를 가공할 때 사용되며 연산 결과로 Stream 타입을 리턴한다. 이때, 이 타입은 종단 연산이 수행되기 전까지 실질적인 데이터 및 연산 결과를 포함하고 있지 않으며 여러 개의 중간 연산을 연결할 수 있다.

**종단 연산**

마지막으로 중개 연산에서 작업된 내용을 바탕으로 결과를 리턴한다. 따라서 terminal operation이라고 부른다.
- 스트림 처리를 마무리하기 위해서 사용되며, 숫자값을 리턴하거나 목록형 데이터를 리턴한다.

### Lazy Evaluation(❗)
- https://dororongju.tistory.com/137

### 반복문과 비교해서 언제 효율적으로 동작하는가?(❗)

## 6. ThreadLocal이란?(❗)
- https://javacan.tistory.com/entry/ThreadLocalUsage

# 📚 이번 예습

## [JSP 2.3 웹프로그래밍] 2장

## 7. JDK, JSP, URL, 웹 페이지에 대해 간략히 설명해보자.

**JDK**

JDK(Java Development Kit)란 Java 언어를 사용하여 프로그래밍을 할 때 필요한 개발 도구 모음이다. JDK는 자바 런타임 환경인 JRE(Java Runtime Environment)를 포함하며, 이외에도 자바 컴퍼일러(javac), 아카이버(jar), 문서 생성기(javadoc) 등의 도구가 포함되어 있다.

**JSP**

![image](https://github.com/MentoringOrganization/Java/assets/103405457/355fa3a4-9d97-40c1-ab64-2b6dca9423bd)

JSP(JavaServer Pages)는 Java를 사용해 웹 페이지를 생성하는 서버 사이드 스크립트 언어이다. HTML 내에 Java 코드를 넣어 동적인 웹 페이지를 만들 수 있다.

이때, JSP는 서버에서 실행되며 클라이언트에게는 그 결과로 생성된 HTML이 전송된다.

이러한 JSP는 웹 애플리케이션의 뷰(View)를 생성하는 데 주로 사용된다.
- HTML 코드 안에 JSP 액션, JSP 스크립트릿, 표현 언어, JSTL 등을 이용해 로직을 추가하여 동적으로 변하는 데이터를 HTML 페이지에 쉽게 표현할 수 있다.

**생성된 JSP 페이지는 웹 서버에서 컴파일되어 서블릿으로 변환되며, 이 서블릿이 실제로 클라이언트의 요청을 처리한다.**

**URL**

https://velog.io/@eunbileeme와 같이 웹 브라우저의 주소줄에 표시되는 것을 URL(Uniform Resource Locator)이라고 부른다. 일종의 주소와 같은 역할을 하며 URL마다 다른 웹 브라우저가 표시된다.

**웹 페이지**

웹 페이지(Web Page)란 웹 브라우저의 주소줄에 URL을 입력했을 때, 출력된 내용을 일컫는다. 흔히 홈페이지라고 부르는 **웹 사이트**는 이런 **웹 페이지의 묶음**이다.

### JDK 8, 11, 17은 다른 버전들과 어떤 차이가 있을까? (쓰다보니 궁금한건데, Java 버전과 JDK 버전은 엄밀히 말하면 다르지만, 혼용해서 쓰는 것 같네요 😮)
- https://velog.io/@alicesykim95/%EC%9E%90%EB%B0%94-%EB%B2%84%EC%A0%848-11-17
- https://techblog.gccompany.co.kr/%EC%9A%B0%EB%A6%AC%ED%8C%80%EC%9D%B4-jdk-17%EC%9D%84-%EB%8F%84%EC%9E%85%ED%95%9C-%EC%9D%B4%EC%9C%A0-ced2b754cd7

JDK 8, 11, 17은 LTS(Long Term Support) 버전으로서 일반적인 경우보다 장기간에 걸쳐 지원하도록 특별히 고안된 소프트웨어의 버전 또는 에디션이다.

따라서 출시 이후 8년 간 보안 업데이트와 버그 수정이 지원되므로 세 가지의 버전 중 하나를 상황에 맞게 선택하여 개발을 진행하는 것이 좋다.

### URL의 구성요소는?

http(프로토콜)://www.11st.co.kr(서버 이름)/html/category/1.html(경로)?xzone=ctgr1^html(쿼리 문자열)

- 프로토콜 : 웹 브라우저가 서버와 내용을 주고 받을 때 사용할 **규칙**이름이다.
- 서버 이름: 웹 페이지를 요청할 **서버의 이름**을 지정한다. 위와 같은 도메인 이름이나 IP 주소를 사용할 수 있다.
- 경로 : 웹 페이지의 **상세 주소**에 해당한다. 즉, 웹 페이지마다 다른 경로를 갖는다.
- 쿼리 문자열 : **추가로 서버에 보내는 데이터**에 해당한다. 같은 경로라 하더라도 입력한 값에 따라 다른 결과를 보여줘야 할 때 사용한다.

## 8. 웹 브라우저와 웹 서버의 관계에 대해 동작 과정과 관련하여 설명해보자

![image](https://github.com/MentoringOrganization/Java/assets/103405457/a6b297f6-2fa8-4fd6-adee-cc63961977bb)

웹 브라우저(클라이언트)가 웹 서버(서버)에 웹 페이지를 달라고 하는 것을 "**요청(request)**"한다고 표현하고, 요청한 웹 페이지를 **웹 브라우저에 제공**하는 것을 "**응답(response)**"이라고 표현한다.

또한 웹 브라우저와 웹 서버는 다른 컴퓨터에 위치하기 때문에 웹 브라우저가 웹 서버에 연결하려면, 웹 서버가 실행 중인 컴퓨터의 주소인 **IP 주소**를 알아야한다.

이러한 IP 주소 대신 사람이 기억하기 쉬운 도메인 주소를 사용한다. 

하지만 웹 브라우저와 웹 서버는 IP 주소를 이용해서 연결하기 때문에, 도메인 이름을 IP 주소로 변환하기 위해 DNS(Domain Name Server)를 거치게 된다.
- 추가로, 각 서버 프로그램은 클라이언트가 연결할 때 (사용 중인) 다른 서버 프로그램과 구분할 수 있도록 포트(Port)를 사용한다.

## 9. HTML, HTTP이란 무엇이며 HTTP 규칙이란?

HTML(HyperText Markup Language)는 웹 페이지를 만들 때 사용하며 HTML 표준에 정의된 ``<html>, <body>, <a>`` 등의 구성 요소를 이용해서 작성한다.

웹 서버는 URL에 해당하는 HTML 문서를 전송하여 웹 브라우저는 렌더링(rendering) 과정을 통해 표현한다.
    
이때, HTML 문서(웹 페이지)를 HTTP라는 방식으로 전송한다.
    
HTTP(HyperText Transfer Protocol)는 웹 브라우저와 웹 서버가 HTML을 비롯해 이미지, 동영상, XML 문서 등 다양한 데이터를 주고 받을 때 사용하는 일종의 규칙이다.
    
HTTP 규칙은 크게 두 가지 관점으로 나뉜다.
- 요청 규칙 : 웹 브라우저가 웹 서버에 HTML과 같은 것을 요청할 때 사용할 데이터 구성 규칙
- 응답 규칙 : 웹 서버가 웹 브라우저에 HTML과 같은 것을 전송할 때 사용할 데이터 구성 규칙

## 10. 정적 자원과 동적 자원의 차이를 예시를 통해 설명해보자

웹 서버는 기본적으로 웹 브라우저가 요청한 경로를 분석한 뒤, 경로에 해당하는 파일을 읽어와 응답 데이터로 전송한다.
    
이때, 파일이 바뀌지 않는 한 고정된 결과(= 동일한 화면)가 출력되는 URL에 해당하는 자원을 정적(static) 페이지 또는 정적 자원이라고 부른다.
- ex. 이미지 파일, HTML 파일 등 자주 바뀌지 않는 파일
    
반대로 파일(= 코드)을 바꾸지 않아도 조건에 따라 다른 응답 데이터를 전송하는 경우가 있다.

예시로, 페이스북의 메세지 내용을 보여주는 주소를 입력하면 URL을 입력한 시점에 따라 다른 내용이 웹 브라우저에 표시된다.
    
이렇게 시간이나 특정 조건에 따라 응답 데이터가 달라지는 자원을 동적(dynamic) 페이지 또는 동적 자원이라고 부른다.
- JSP, PHP 등 많은 웹 관련 기술들은 이러한 동적 페이지를 만드는 데 사용되는 프로그래밍 기술이다.

## [JSP 2.3 웹프로그래밍] 3장

## 11. request 기본 객체 vs response 기본 객체
    
request 기본 객체는 JSP에서 가장 많이 사용되는 기본 객체로서 웹 브라우저의 요청에 관련이 있다.
    
웹 브라우저에서 웹 사이트의 주소를 입력하면 웹 브라우저는 해당 웹 서버에 연결한 후 요청 정보를 전송하는데, 이 요청 정보를 제공하는 것이 request 기본 객체이다.
    
response 기본 객체는 request 기본 객체와 반대의 기능을 수행한다. **request 기본 객체**가 **웹 브라우저가 전송한 요청 정보**를 담고 있다면 **response 기본 객체**는 **웹 브라우저에 보내는 응답 정보**를 담는다.

## 12. GET vs POST?

![image](https://github.com/MentoringOrganization/Java/assets/103405457/aac8d330-5d8c-4175-9adc-442a76dd16eb)
    
웹 브라우저는 GET 방식과 POST 방식 중 한 가지를 이용하여 파라미터를 전송한다. 이러한 두 가지 방식은 다음과 같은 차이점이 있다.
    
- GET 방식은 요청 URL에 파라미터를 붙여서 전송한다. 이때, URL이 쿼리 문자열로 전송되기 때문에, 폼을 사용하지 않아도 파라미터를 전송할 수 있다.
> URL의 경로 뒤에 물음표(?)와 함께 파라미터를 붙여 전송하는 쿼리 문자열 형식을 사용한다.
    - 각각의 파라미터는 앰퍼샌드(&) 기호로 구분되며, 파라미터의 이름과 값은 등호 기호(=)로 구분한다.
- 웹 브라우저, 웹 서버 또는 웹 컨테이너에 따라 전송할 수 있는 파라미터 값의 길이에 제한이 있을 수 있다.
   
---
    
- 반면 POST 방식은 파라미터를 함께 전송하지 않고, 데이터 영역을 이용해서 파라미터를 전송한다.
- 데이터 영역을 이용해서 데이터를 전송하기 때문에 파라미터 값의 길이에 제한이 없다.

## [JSP 2.3 웹프로그래밍] 4장

## 13. JSP 처리 과정 중 출력 버퍼를 사용함으로써 얻는 장점은 어떤 것이 있을까?

![image](https://github.com/MentoringOrganization/Java/assets/103405457/9c0308d3-99a9-40e4-a553-36be6b0c2d66)

JSP 페이지가 생성하는 출력 내용을 버퍼에 저장했다가 한꺼번에 웹 브라우저에 전송할 때 생기는 장점은 다음과 같다.

1) 데이터 전송 성능 향상
2) JSP 실행 도중에 버퍼를 비우고 새로운 내용 전송 가능
3) 버퍼가 다 차기 전까지 헤더 변경 가능

순서대로 자세히 살펴보자.

1) 버퍼를 사용하면 작은 단위로 데이터를 전송하는 것이 아니라 한 번에 큰 단위로 데이터를 전송하는 것이 가능하기 때문에 성능이 향상된다.
2) <jsp:forward> 기능과 에러 페이지 처리 기능이 가능하다. 즉, JSP 페이지가 생성한 결과를 일단 버퍼에 저장하기 때문에 버퍼에 보관된 데이터가 일정 크기가 될 때까지 웹 브라우저에 전송되는 데이터는 없다. 그러므로 JSP 페이지가 생성한 내용이 있다 하더라도 버퍼에 저장된 데이터가 웹 브라우저로 전송되기 전까지는 버퍼에 보관된 데이터를 지우고 새로운 내용을 전송할 수 있다.
3) HTTP 프로토콜의 구조 상, 응답 상태 코드와 함께 헤더 정보를 가장 먼저 웹 브라우저에 전송해야 한다. 이런 이유로 WAS(웹 컨테이너)는 처음 버퍼의 내용을 웹 브라우저로 전송하기 전에 헤더 정보를 전송한다. **따라서 첫 번째로 버퍼의 내용을 웹 브라우저에 전송하기 전까지는 헤더 정보를 얼마든지 변경할 수 있다.**

## [JSP 2.3 웹프로그래밍] 9장

## 14. 쿠키란 무엇이며 쿠키의 동작 방식은 어떻게 이루어질까?
``쿠키(Cookie)``는 웹 브라우저가 보관하는 데이터이다.

웹 브라우저는 웹 서버에 요청을 보낼 때 쿠키를 함께 전송하며, 웹 서버는 웹 브라우저가 전송한 쿠키를 사용해서 필요한 데이터를 읽을 수 있다.

이러한 쿠키는 웹 브라우저와 웹 서버 양쪽에서 생성할 수 있는데 **JSP에서 생성하는 쿠키**는 **웹 서버**에서 생성하는 쿠키이다.

---

쿠키 동작 방식은 다음 그림과 같다.

![image](https://github.com/MentoringOrganization/Java/assets/103405457/22d28929-c2b5-4b6d-b433-49c6f8bac2a3)

- 쿠키 생성 단계 : 쿠키를 사용하기 위해 쿠키를 생성한다. 이때, JSP 프로그래밍에서 쿠키는 웹 서버에서 생성하며 생성한 쿠키를 응답 데이터의 헤더에 저장해서 웹 브라우저에 전송한다.
- 쿠키 저장 단계 : 웹 브라우저는 응답 데이터에 포함된 쿠키를 쿠키 저장소에 보관한다. 이때, 쿠키의 종류애 따라 메모리나 파일에 저장한다.
- 쿠키 전송 단계 : 웹 브라우저는 저장한 쿠키를 요청이 있을 때마다 웹 서버에 전송한다. 웹 서버는 웹 브라우저가 전송한 쿠키를 사용해서 필요한 작업을 수행한다.

이러한 쿠키는 일단 웹 브라우저에 저장되면, 웹 브라우저는 쿠키가 삭제되기 전까지 웹 서버에 쿠키를 전송한다.

**따라서 웹 애플리케이션을 사용하는 동안 지속적으로 유지해야 하는 정보는 쿠키를 사용해서 저장하게 된다.**

---

### 쿠키의 구성요소는?

- 이름(⭐) : 각각의 쿠키를 구별하는 데 사용되는 이름
- 값(⭐) : 쿠키의 이름과 관련된 값
- 유효시간 : 쿠키의 유효 시간
- 도메인 : 쿠키를 전송할 도메인
- 경로 : 쿠키를 전송할 요청 경로

하나의 웹 브라우저는 여러 개의 쿠키를 가질 수 있는데, 각 쿠키를 구분할 때 이름을 사용한다. 이러한 쿠키를 값을 가지며 서버는 이 값을 사용해서 원하는 작업을 수행한다.

## 15. 쿠키는 기본적으로 그 쿠키를 생성한 서버에만 전송된다. 그렇다면, 같은 도메인을 사용하는 모든 서버에 쿠키를 보내야할 때는 어떻게 처리해야할까?

``setDomain() 메소드``를 통해 생성할 쿠키를 전송할 수 있는 도메인을 지정하여 같은 도메인을 사용하는 모든 서버에 쿠키를 보내도록 한다.

- .somehost.com : 점으로 시작하는 경우 관련 도메인에 모두 쿠키를 전송한다.
> ex. .somehost.com 으로 설정 → mail.somehost.com, www.somehost.com, javacan.somehost.com에 모두 쿠키를 전송
- www.somehost.com : 특정 도메인에 대해서만 쿠키를 전송

### 이때, 주의할 점은?

현재 서버의 도메인 및 상위 도메인만 전달할 수 있다.
> ex.
```
JSP 페이지가 실행되는 서버의 주소 : mail.somehost.com
setDomain() 메소드에 줄 수 있는 값 : mail.somehost.com 또는 .somehost.com
setDomain() 메소드에 줄 수 없는 값 : www.somehost.com
```

### 웹 브라우저가 타 도메인으로 지정한 쿠키를 받지 않는 이유는?

보안 관련 문제가 발생할 수 있기 때문이다.

> 예를 들어, wwww.somehost.com 서버의 프로그램이 "ROLE" 쿠키를 사용해서 보안정책을 펼친다고 가정해보자.

이때, 임의의 다른 서버에서 "ROLE" 쿠키의 값을 마음대로 변경할 수 있다면 www.somehost.com의 웹 어플리케이션 보안은 뚫리게 된다.

따라서 웹 브라우저는 현재 서버의 도메인과 다른 도메인에 대한 쿠키 생성은 허용하지 않는다.

### 왜 웹 사이트에서 아이디를 기억할 때, 쿠키를 사용할까?

일반적으로 사용자가 로그인에 성공하면 아이디를 값으로 저장하고 있는 쿠키의 유효 시간을 1달 정도로 여유롭게 잡아서 생성한다.

그러면 웹 브라우저를 닫더라도 유효시간이 충분히 남아 있기 때문에, 다음에 웹 브라우저를 실행할 때 아이디를 저장하고 있는 쿠키를 사용할 수 있다.

**따라서 웹 프로그램은 아이디 쿠키가 존재하면 쿠키 값을 로그인 폼에 출력해서 아이디 기억하기 기능을 구현하게 된다.**

비슷한 방식으로 로그인 정보를 쿠키에 보관하면 자동 로그인 기능도 구현할 수 있다.

## [JSP 2.3 웹프로그래밍] 10장

## 16. 쿠키 vs 세션
- p 232

### session 기본 객체란?
- p 234
