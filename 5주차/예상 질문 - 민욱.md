# 💡 (6주차) 자바 예상 질문 정리

# 📜 이전 복습

## Socket과 Port를 비교하라.
Client가 Server로 요청을 보낸다고 하자. Client가 Server에 요청을 보낼 때, 필요한것은 IP주소만이 아니다. IP주소를 통해 알 수 있는것은 네트워크에 연결된 Server컴퓨터의 위치까지다. Server 컴퓨터에는 하나의 프로세스만 동작하고 있는 것이 아니다. 따라서 Client는 Server 컴퓨터에서 동작하고있는 여러 프로세스 중 어느 프로세스에 요청을 보내야 하는지를 알아야 한다. 이때 사용되는 것이 Port이다. Port는 컴퓨터의 여러 데이터를 보내고 받을수 있는 창구중하나이다. 프로세스는 이 중 하나의 Port를 listen하고 있으며 하나의 Port를 여러 프로세스가 할당받을수는 없다.
즉, 프로세스:포트는 1:n관계에 있다.
정리하자면 Client가 Server로 요청을 보낼 때, 목적지를 특정하기 위해서는 Ip주소와 Port가 필요하다. Socket이란 Ip주소+port번호를 합쳐서 부르는 말이다.

### Server Socket 과 Socket을 비교하고 역할을 설명하라.
ServerSocket 객체는 클라이언트의 연결 요청을 수신한다. 클라이언트의 연결 요청이 오면 Socket객체를 생성하고 이를 통해 클라이언트와 통신을 가능하게 한다.
Socket은 실제로 Server와 Client간에 송수신에 쓰이는 객체이다. 클라이언트의 연결 요청이 오면 ServerSocket은 Socket을 생성하고 이 Socket이 실제 클라이언트와의 송수신에 쓰인다.


### Server Socket의 backlog를 설명하라. backlog를 넘어서는 요청이 오면 어떻게 되는가?
ServerSocket의 backlog는 client요청의 대기 열이다. client요청은 해당 대기열에 대기하다가 처리할 수 있는 상황이 되면 해당 대기열에서 빠져서 처리된다. backlog의 범위를 넘어서는 요청이 들어오게 되면 Connected refused 오류가 발생한다.

## TCP/UDP의 차이를 설명하라.
TCP는 데이터 손실이 발생하지 않음을 보장하는 신뢰성 높은 protocol이다. 반면 UDP는 데이터 손실이 발생할 수 있다.
하지만 UDP는 TCP보다 속도가 빠르다는 장점이 있다.

### TCP의 3way-handShake, 4way-handShake에 대해 설명하라.
TCP에서 상대와 연결하기 위해 3번의 데이터를 주고받는데 이를 3way-handShake라 한다. 상대방과의 연결을 끊기위해서 4번의 데이터를 주고받는데 이를 4way-handShake라 한다.

**3way-handShake 과정**

![image](https://user-images.githubusercontent.com/46997074/236989188-d9b52f75-5181-490b-9567-57608484e5c9.png)

client는 처음에 SYN요청을 보낸다. 이는 Server와 연결하고싶다는 요청을 보낸것이다. Server는 해당 요청을 받으면 SYN요청의 SEQ+1을 ACK로 하여 응답을 보낸다.이는 요청을 잘 받았고, Server에서도 client에게 연결해달라는 요청이다. 해당 요청을 받은 Client는 요청을 잘 받았고 연결도 완료했다는 의미로 한번더 패킷을 보낸다. 해당 과정을 거치면 연결이 완료된다.

**4way-handShake 과정**

![image](https://user-images.githubusercontent.com/46997074/236989259-63427c1f-8507-4371-bc57-64432211c518.png)

client가 close메서드를 호출하면 FIN메시지가 Server에게 전달된다. 이는 연결을 끊고자 하는 요청이다. 해당 요청을받은 Server는 ACK메시지를 보낸다. 이는 요청을 잘 받았고 잠시 기다리라는 의미이다. 이후 server는 close메서드를 호출하고 client에게 FIN메시지가 전달된다. 해당 메시지를 받은 Client는 ACK요청을 통해 메시지를 잘 전달받았음을 알리고 socket을 닫는다.
server또한 ACK요청을 받으면 socket을 닫고 연결이 끊긴다.

### UDP는 왜 TCP보다 빠르고 TCP는 왜 UDP보다 신뢰성이 높은지 설명하라.
TCP는 요청을 보낼 때, SEQ, ACK를 함께 전달한다. SEQ는 송신자가 보내는 패킷의 순서이고, ACK는 수신자가 보내야하는 다음 패킷의 순서이다.
C와 S가 요청을 주고받는다고 하자. C가 SEQ :1000, ACK: 2000, size=100인 패킷을 전달하면 S는 SEQ:2000,ACK:1101, size 100의 패킷으로 응답한다.
그럼 C는 1000번 패킷을 전달받았으며 size가 100인것을 봤을 때, 데이터 손실이 없었구나를 알 수 있다. (1000(SEQ) + 100(SIZE) + 1 = ACK)
따라서 TCP는 데이터 무손실을 보장할 수 있는 protocol인 반면, UDP는 이러한 과정이 없기 때문에 데이터가 손실되지 않음을 보장하지 못한다.
반면, UDP는 이러한 과정이 없기 때문에 데이터 전송 속도가 매우 빠르다.

## Non reifiable varargs Type에 대해 설명하여라.
Non reifiable varargs type은 자바에서 제네릭을 사용하지 않는 버전과의 호환성을 위해서 제공했던 기능 때문에 발생한다.
reifiable은 실행시 타입 정보가 남아있는 타입을 의미하고,
non reifiable은 컴파일시 타입 정보가 손실되는 타입을 말한다.
generic은 컴파일시에만 사용되고 사라지는 특징을 가지고 있다.
?? 모르겠다.

## Lambda 표현식과 Stream에 대해 설명하고 이것이 왜 나왔는지 설명하라.
Lambda와 Stream은 모두 java8에서 추가된 기능으로 함수형 프로그래밍을 지원하는 기술이다.
Lambda는 익명 함수를 만들 수 있는 간단한 문법이다.
원래는 해당 기능을 수행하는 메서드를 만들기 위해 클래스도 새로 만들어야 하고, 객체도 생성해야 해당 메서드를 호출할 수 있다. 그러나 해당 기능이 반복적으로 사용되는 것이 아니라면 이는 비효율적이다.Lambda는 오직 람다식 자체로 익명함수를 만드는 기술이다.
Stream은 다양한 방식으로 저장된 데이터를 읽고 쓰기 위한 공통된 방법을 제공한다. 데이터를 저장하기위해 배열이나 컬렉션을 통해서 저장하곤 한다. 이렇게 저장된 데이터에 접근하기 위해서 java8이전에서는 반복문이나 iterator를 사용하여 매번 새로운 코드를 작성했어야했다. 이는 코드가 너무 길어지고 가독성이 떨어지며 대부분 일회성으로 사용되는 코드라 재활용성도 떨어진다.
java8에서는 코드 가독성을 높이고 데이터를 다루는 방법을 표준화 하기위해 Stream을 도입했다.


### Lambda와 익명클래스의 관계를 설명하라.
Lambda식은 익명 클래스의 객체와 동등하다. 아래 예시 코드를 살펴보자.
**람다식**
```
    (int a, int b) -> a > b ? a : b;
```

**익명 클래스**
```
    new Object(){
        int max(int a, int b){
            return a > b ? a : b;
        }
    }
```

참조변수가 있어야 객체의 메서드를 호출 할 수 있으므로 익명 객체의 주소를 참조변수에 저장해야한다. 참조변수의 타입은 클래스 혹은 interface여야 하며 람다식과 동등한 메서드가 정의되어 있어야 한다. 따라서 아래 MyFunction이라는 interface를 정의하면 아래와 같이 나타낼 수 있다.

```
    interface MyFunction{
        public abstract int max(int a, int b);
    }

    MyFunction f = new MyFunction(){
        public int max(int a, int b){
            return a > b ? a : b;
        }
    }

    int big = f.max(5,3);
```

Lambda식이 익명 객체와 동등하다는 말은 실제 Compiler가 컴파일 시점에 람다식을 위와같은 형태로 수정하게 된다는 의미이다.

### Functional Interface 어노테이션에 대해 설명하라.
위에서 말한듯이 Lambda식은 익명 객체로 컴파일 시점에 변환된다.
해당 익명객체의 참조변수는 해당 메서드를 선언하고있는 인터페이스인데 해당 인터페이스를 Functional Interface라 부른다.
Functional Inteface에는 메서드가 하나만 선언되어있어야한다.

# 📚 예습

## 1. 쿠키가 무엇인지 설명하라.
쿠키란 브라우저에서 데이터를 저장하는 방식 중 하나이다. 쿠키는 이름, 값, 유효시간, 도메인, 경로로 구성되어있다. 
Client는 Server에게 요청을 보내고 Server는 응답한다. Server가 응답할 때, Cookie를 만들 것을 요청하면 해당 브라우저는 Cookie를 생성한다. 브라우저는 요청을 보내는 목적지가 도메인, 경로와 일치하면 Cookie를 함께 보내고 Server는 이름과, 값을 비지니스 로직에 이용한다. 쿠키는 유효기간을 가지고있고 유효기간이 지나면 삭제된다.
### 쿠키의 동작 방식을 설명하라.
위에서 함께 설명함.
### 쿠키를 구성하고 있는 요소에 무엇이 있는지 말하라.
위에서 함께 설명함.
### 쿠키가 실제로 사용되는 사례를 설명해 보라.
Cookie가 실제로 사용되는 사례를 몇가지 설명하겠다.
1. 로그인 처리
클라이언트가 로그인을 하면 서버는 로그인이 성공했다는 쿠키를 생성하고 클라이언트에게 전달한다. 클라이언트는 해당 서버로 요청을 보낼 때마다 해당 쿠키를 함께 보내며, 이를 통해 서버는 인증된 사용자로 취급하고 응답을 해준다.
2. 조회수 처리 (제 경험이며 실제로 이렇게 처리하는지는 잘 모르겠습니다.)
조회수 기능을 구현할 때, 이미 조회한 유저가 여러번 반복해서 조회하거나, 새로고침과 같은 행동을 취할 때, 조회수가 중복해서 카운트되지 않도록 구현하길 원한다고 하자.
서버는 Cookie를 no-expire(무기한)으로 생성하여 클라이언트에게 전달할 수 있다. 해당 쿠키를 가진 브라우저는 게시글에 접속할 때, 쿠키를 함께 전달하게 되고 서버는 이미 접속한 적이 있는 유저임을 인지하고 조회수를 중복 카운트하지 않을 수 있다.

## 2. Hosts 파일의 역할을 설명하라.
브라우저 주소창에 www.naver.com을 입력하여 네이버 홈페이지에 접속하는 경우를 생각해보자. 우리는 www.naver.com을 입력하지만 실제 접속하는 서버는 IP주소를 이용해 접속한다. 우리는 DNS서버를 거쳐 www.naver.com에 해당하는 도메인주소가 어느 ip주소를 가지는지를 확인하는 과정을 거쳐야한다.
Hosts파일은 DNS에서 IP주소를 찾는 과정을 생략하여 인터넷 속도를 향상시키는 방법이다.
Hosts파일에는 도메인 주소와 ip주소가 저장되어 있어서 DNS를 거치지 않고 도메인 주소의 ip주소를 찾아낼 수 있다.

## 3. URI의 구조를 설명하라.
![image](https://user-images.githubusercontent.com/46997074/237031835-dc0a4bd4-a3dd-4bbd-9646-6158dca824d0.png)
</br>
Scheme(Protocol) : 어떤 프로토콜을 이용하여 접근할지를 나타낸다.</br>
Host : Host컴퓨터의 도메인 주소/IP 주소가 입력되는 란이다.</br>
Port : 어떤 Port를 사용해 접근할지를 나타낸다.</br>
Path : 서버에 제공하는 자원의 경로를 의미한다.</br>
Query String : 클라이언트가 서버에 요청할 때, 파라미터를 전송하는 방식으로 key, value로 이루어진다.</br>
Fragment : 요청하는 자원의 특정 요소를 나타낸다.</br>

## 4. 세션에 대해 설명하라.
Cookie가 브라우저에 데이터를 저장하고있는 방법이라면, 세션은 반대로 서버에 데이터를 저장하고 있는 방법이다. 세션은 브라우저와 일대일로 대응되며 해당 브라우저에 대해 유지해야 하는 정보를 저장할 수 있다.
session은 개발자가 직접적으로 삭제할 수도 있고, 유효기간이 존재하여 유효기간이 지나면 자동으로 삭제된다.

### 세션이 사용되는 사례를 설명하라.
세션이 사용되는 가장 대표적인 사례로 장바구니를 꼽을 수 있다.
사용자가 결재를 하거나 장바구니를 비울때 까지 서버는 사용자의 장바구니를 유지해야한다. 이를 위해 주로 Session을 많이 사용한다.

?? 저는 인정 못하겠습니다.

## 5. 로그인에 쿠키를 사용하는 방식과 어떠한 문제점이 있는지 설명하라.
Cookie에 id, pwd를 넣어 사용하는것은 중요 정보가 누출될 가능성이 너무 높다.

### 로그인에 쿠키+세션을 사용하는 방식과 어떠한 문제점이 있는지 설명하라.
사용자의 정보와 같은 중요한 정보는 세션에 저장한다. 세션에는 sessionId라고 하는 식별자가 있는데 해당 id를 쿠키에 넣어 사용한다. 이를 통해 비교적 보안수준을 올릴 수 있다. 하지만 http의 중요한 특성인 stateless에 위배된다는 문제점이 발생한다.
이때문에 1번 서버에 로그인한 유저가 2번 서버에 요청을 하게되면 문제가 발생한다.
이를 해결하기 위한 방법으로 두가지가 있다.

1. 세션 클러스터링
서버간 로그인 정보가 담긴 세션을 공유하는 방식이다. 인프라를 위해 많은 서버 리소스를 사용해야한다는 단점이 있다.

2. 스티키 세션
처음 요청한 서버를 기록해 두고 이후 요청도 모두 같은 서버가 처리하도록 하는 방식이다. 로드 밸런싱이 제대로 이루어지지 못한다는 단점이 있다.

### JWT를 사용한 로그인 방식이 존재한다. JWT를 사용하는 방식에 대해 설명하라.

![image](https://github.com/MentoringOrganization/Java/assets/46997074/a29f1461-3141-442a-9b10-78c1ce0f36bf)

### 쿠키,세션을 사용한 로그인 방식과 JWT를 통한 로그인 방식에 어떤 장단점이 있는지 논하라.

## 6. OSI 7계층에서 각 계층의 역할을 간략하게 논하여라.

### HTTP/HTTPS는 7계층 중 어디에 속하는 protocol인가?

### TCP/UDP는 7계층 중 어디에 속하는 protocol인가?


