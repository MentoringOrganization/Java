## Q1. 상속을 하기 위해선 어떤 예약어를 사용하며, 상속이란 무엇인가?
- extend

상속이란 부모 클래스에 선언되어 있는 public 및 protected로 선언되어 있는 모든 변수와 메소드를 자식 클래스에서 자유롭게 사용할 수 있는 개념이다.

### 상속은 왜 사용하는가?
상속을 사용하는 이유는 필요할 때마다 기능들을 만들 필요 없이, 잘 만들어 놓은 하나의 클래스(부모 클래스)를 상속받아 추가적인 기능을을 넣어 사용하기 위함이다.

## Q2. 부모 클래스의 생성자를 자식 클래스에서 직접 선택하려고 할 때 사용하는 예약어는 무엇인가?
- super

### 위의 예약어를 사용하는 이유는 무엇인가?
자바는 부모 클래스의 매개 변수가 없는 기본 생성자를 찾는 것이 기본이므로, 부모 클래스에 매개 변수가 있는 생성자만 있는 경우에는 컴파일에 오류가 발생한다.

또한 경우에 따라 기본 생성자와 매개 변수가 있는 생성자 중 선택해야 하는 상황이 있을 수도 있으므로, 두 경우 모두 super이라는 예약어를 사용해야 한다.

즉, 부모 클래스에 기본 생성자가 있다는 가정하에 명시적으로 부모 생성자를 선택해서 호출한다.

## Q3. 메소드 Overrding(오버라이딩)이란 무엇인가?
부모 클래스에 선언되어 있는 메소드와 동일하게 선언되어 있는 메소드를 자식 클래스에 선언했을 때, 자식 클래스의 메소드만 실행되는 개념이다.

즉, 부모 클래스의 메소드를 복제해서 자식 클래스에서 기능을 추가하여 부모 클래스의 기능은 무시하고, 자식 클래스에서 덮어쓰는 개념이다.

### Overriding을 구현하기 위해선 자식 클래스에서 부모 클래스의 어떤 것들이 동일해야하는가?
- 접근 제어자, 리턴 타입, 메소드 이름, 매개 변수 타입 및 개수

### 메소드 Overloading과 메소드 Overriding의 차이는 무엇인가?
쉽게 말해서 메소드 Overloading은 "확장"이고 메소드 Overriding은 "복제"라고 볼 수 있다.

메소드 오버로딩은 메소드의 매개 변수를 다르게 하는 것, 즉 같은 이름의 메소드를 중복 정의하여 매개 변수들을 확장하는 개념이다.

반면 메소드 오버라이딩은 부모 클래스의 메소드 시그니처와 동일하게 선언한 후 기능을 추가하는 것, 즉 부모 클래스의 기능을 복제한 후 기능을 추가하여 덮어쓰는 개념이다.

## Q5. 참조 자료형(Refernce Type)의 형변환이란 무엇인가?
먼저 자식 클래스에서는 부모 클래스에 있는 메소드와 변수들을 사용할 수 있다. 하지만 반대로, 부모 클래스에서는 자식 클래스의 메소드와 변수들을 사용할 수 없다.

즉, 자바 컴파일러는 자식 객체를 생성할 때 부모 생성자를 사용하면 안된다고 명시한다. 이때, 명시적으로 형 변환(casting)을 수행해야 하고 참조 자료형의 경우도 동일하다.

정리하자면 기본 자료형과 동일하게 참조 자료형의 경우, 자식 타입의 객체를 부모 타입으로 형 변환하는 것은 자동으로 이루어지지만 그 반대는 부모 타입의 실제 객체가 자식 타입이라는 가정하에 명시적으로 타입을 지정해줘야 한다.

이때 수행하는 것이 참조 자료형의 형변환이다.

## Q6. 형변환을 하기 전, 객체의 타입을 확인하는 예약어는 무엇인가?
- instanceof

### 6에서 이야기한 예약어를 사용할 때, 주의해야할 점은 무엇인가?
부모 타입부터 확인하는 것이 아니라 가장 하위에 있는 타입부터 확인을 해야 제대로 점검이 이루어진다.

경우에 따라 부모 타입부터 점검할 경우 자식 클래스의 객체가 부모 클래스의 타입에 값을 넣지도 못했기에 부모 클래스의 타입으로 판별이 나는 경우가 있다.

따라서 if와 같은 조건문에서 instanceof를 사용할 때, 가장 하위에 있는 타입부터 확인하여 제대로 boolean 값을 도출하도록 해야한다.

## Q7. Polymorphism이란 무엇인가?
형 변환을 하더라도 실제 호출되는 것은 원래 객체에 있는 메소드가 호출된다는 개념이다.

## Q8. Object 클래스는 무엇인가?
모든 자바 클래스의 부모인 클래스이다. 즉, 우리가 사용한 모든 클래스는 자동으로 Object 클래스의 상속을 받았다고 볼 수 있다.

### toString()이란 무엇이며, 어느 때에 사용되는가?
해당 클래스가 어떤 객체인지를 알 수 있는 메소드이다.

즉, 객체가 가지고 있는 정보나 값들을 문자열로 만들어 리턴하는 메소드이다.

## Q9. equals()와 hashCode()의 차이는 무엇인가?
### 왜 둘을 붙여서 설명하는가?
두 메소드는 동등성과 동일성으로 연관지어 비교할 수 있다.

두 객체를 비교할 때 하나의 객체만 존재하고 다른 객체는 그 객체를 참조하는 레퍼런스 변수를 가지고 있다면 동일성, 즉 두 개의 객체가 주소 값이 같기 때문에 완전히 동일하다고 보는 경우이다. 이 경우, hashCode()의 값이 동일한 경우이다.

반대로 동등성인 경우, 두 객체의 주소 값은 서로 다르지만 내용이 같은 경우이므로 hashCode() 값은 다르나 equals() 값이 같은 경우이다.

## Q10. interface vs abstract vs 클래스의 차이는 무엇인가?
크게 interface class와 abstract class의 차이부터 볼 수 있다.

인터페이스 클래스(interface)는 메소드의 내용이 없는 메소드가 선언되어 있다. 즉, 설계의 관점에서 구현이 안된 메소드를 정의해놓고 해당 인터페이스를 구현한 클래스들이 구현이 안된 메소드를 오버라이딩하여 구현(implemnts)한다.

반면 추상 클래스(abstract)는 하위 클래스들이 abstract의 기능을 구현하고 확장(extends; 상속)하여 사용할 수 있다. 즉, 구현이 된/구현이 안된 메소드가 있을 수도 있고 없을 수도 있다.

일반 클래스는 인터페이스 클래스나 추상 클래스와 달리 구현이 된 메소드가 반드시 존재해야 하며, 구현(implements)를 수행할 수 없다.

## Q11. enum vs final의 차이는 무엇인가?
## Q12. enum이란 무엇이며~
enum 타입은 클래스, 즉 열거형 클래스라고 불리운다. 따라서 enum 클래스에 있는 상수들은 별도로 타입 및 값을 지정할 필요가 없이 이름만 콤마로 구분하여 나열한다.

반면 fianl은 각각의 상수에 값을 추가할 때마다 지정해줘야 한다.

따라서 클린 코드를 통하여 가독성을 높이고, 구현의 의도가 열거임을 분명히 할 때 enum을 사용한다.

### 클래스/메소드/변수에 final을 선언할 때의 차이는 무엇인가?
클래스에 fianl을 선언할 시, 상속을 수행할 수 없으며 메소드에 fianl을 선언할 시 Overriding을 더이상 진행할 수 없다. 또한 변수에 final을 선언할 시 상수(constant)로서 값을 변경할 수 없다.

## Q12. enum에서 사용할 수 있는 접근 제어자는 무엇인가?
- 아무도 명시하지 않는 package-private(default), private

## Q13. 자바에서 예외란 무엇이며, 어떤 종류가 있는가?
예상치 못한 일이 발생할 수 있음을 인지하고, 안전장치를 마련하는 것이라고 볼 수 있다.

즉, 예상을 했든 하지 않았든 예외적인 일이 발생하면 "예외"로써 수행한다.

- checked exception
- error
- unchecked exception(runtime exception)

### 각각 차이는 무엇인가?
checked exception은 개발자가 반드시 예외처리를 해야한다. 즉, try-catch or throws를 통해 예외를 던져야한다. 또한, 컴파일 단계에서 확인이 된다.

error는 자바 프로그램 밖에서 발생한 예외이다. 반면 checked exception, unchecked exception은 자바 프로그램 안에서 발생하는 예외이다.

unchecked exception(runtime exception)는 예외처리를 하지 않아도 가능하며, 명시적인 예외 처리를 강제하지 않는 특성을 가지고 있기 때문에 try-catch or throws를 통해 예외를 던지지 않아도 된다. 또한, 실행 단계에서 확인이 된다.

## Q15. String이란 어떤 클래스인가?
자바에서 문자열을 표현하기 위해서 사용하는 클래스로, Obejct 클래스를 상속 받는 클래스 중 유일하게 객체를 생성하지 않고 사용할 수 있다.

### new String(" ~ ") vs " ~ "의 차이는 무엇인가?
### Constant Pool이란 무엇이며, 어느 때에 사용되는가?
일반적으로 " ~ "(이하 리터럴 방식)을 new String(" ~ ") 보다 많이 사용한다.

리터럴 방식은 JVM의 Heap 영역 내 String Constant Pool(리터럴 상수 값을 저장하는 곳, String/숫자/식별자 이름 등이 포함)에 저장되고 호출될 때 꺼내어 재사용한다.

반면 new String을 사용하면 같은 내용이라도 Heap 영역에 매번 객체가 생성되며, ==을 비교하면 값이 계속 달라진다.

### == vs equals()의 차이는 무엇인가?
==은 동일성, 즉 hashCode()의 값이 같은 경우이다.

equals()는 동등성, 즉 hashCode()의 값이 다른 경우이다.

## Q16. StringBuilder vs StringBuffer의 차이는?
String은 immutable(불변)의 객체이므로 그 값을 바꿀 수 없으며, String을 사용하여 문자열을 더할 시 더해진 새로운 String이 생성되고 기존 객체는 버려진다. 

이 경우, StringBuilder는 Thread safe(여러 스레드로부터 동시에 접근이 이루어져도 프로그램의 실행에 문제가 없는 것)하지 않고, StringBuffer는 Thread safe하다. 이때, StringBuilder가 속도는 더 빠르다.

두 메소드는 문자열을 더하더라도 새로운 객체를 생성하지 않기 때문에 String을 사용하여 문자열을 더할 시 사용하고, append 메소드를 통해 새로운 문자열을 더한다.
