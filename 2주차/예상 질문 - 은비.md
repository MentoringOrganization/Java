# 💡 (3주차) 자바 예상 질문 정리

# [자바의 신] 21장

## Generic, 즉 제네릭은 무엇이며 왜 사용하는가?
제네릭은 데이터의 타입(data type)을 일반화한다(generalize), 즉 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시에 미리 지정하는 방법이다.

`
public class WildcardGeneric <W> {
  w wildcard;
  public void setWildcard(W wildcard) {
  ..
  }
 }
`

제네릭을 사용하는 이유는 타입 형 변환 시, 발생할 수 있는 문제점을 컴파일할 때 점검할 수 있도록 사용한다.

## 제네릭에서 꺽쇠 안에 들어갈 타입(E, N, T, ..) 중 배열에는 주로 E가 쓰인다. 왜 그럴까?
사실 컴파일과 실행 시 어떤 제네릭 타입을 사용하든 에러 없이 성공한다.

즉, E로 선언한 제네릭 클래스든 T로 선언한 제네릭 클래스든 어떤 타입의 클래스가 들어가도 테스트는 성공한다.

그러나, 별개로 구분 지은 이유는 제네릭 타입의 명칭에서 확인할 수 있다.

E는 Element, 즉 요소라는 뜻으로 ArrayList와 같이 요소들(오브젝트)를 배열처럼 저장하기 때문에 이러한 구조에는 E로 선언하는 것이 일반적이다.

따라서 배열 기반으로 되어 있는 구조에는 E가 어울리고, 그 외의 경우에는 T를 주로 사용한다.


### 제네릭 타입 중 물음표는 무엇이며, 왜 사용하는가?

<pre> <code>
public void callWildcardMethod() {
  WildcardGeneric<String> wildcard=new WildcardGeneric<String>();
   ..
  wildcardStringMethod(wildcard);
}

public void wildcardStringMethod(WildcardGeneric<String> c) {
  ..
  }
}
</code>
</pre>

위와 같이 선언했을 경우, wildcardStringMethod()의 매개변수는 반드시 String을 사용하는 WildcardGeneric의 객체만 받을 수 있다.

이런 경우, 다른 타입으로 선언된 wildcardGeneric<Integer>와 같이 다른 타입으로 선언된 wildcardGeneric 객체를 받으려면 ?(wildcard 타입)와 같이 선언한다.

즉, 어떤 타입이 제네릭 타입이 되더라도 상관 없으나 해당 타입을 정확히 모르기 때문에 String과 같이 받을 수는 없고 Object로 처리해야 한다.

따라서 어떤 객체를 ?로 선언하고, 그 객체의 값은 가져올 수 있는 있으나 특정 타입으로 값을 지정하는 것은 불가능하다. (?는 메소드의 매개변수로만 사용하는 것이 좋다.)

# [자바의 신] 22~24장

## Collection이란 무엇이며 왜 사용하는가? 
컬렉션이란 **데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현**한 것이다.

여러 개의 객체들을 하나의 객체에 담을 때 사용하는 대표적인 방법으로 배열이 있지만, 배열의 경우 정적 메모리 할당(선언한 크기의 공간만큼 사용)을 하는 반면 컬렉션은 동적 메모리 할당(공간이 계속 필요한만큼 추가)을 하기 때문에 컬렉션이 메모리면에서 효율적이다.

## Collection의 종류와 각각의 특징은?

![image](https://user-images.githubusercontent.com/103405457/232737504-9678ba6f-a52c-4032-86ed-522300c4f682.png)

크게 List, Set, Queue, Map으로 총 4가지의 자료 구조로 나뉜다.

이 중 List, Set, Queue는 Collection이라는 하나의 인터페이스를 이용하여 구현되어 있으며, Map은 별도의 인터페이스로 선언되어 있다. 

> List

List는 목록형 자료형으로 배열처럼 순서를 고려하지만, 필요한 만큼 크기를 추가할 수 있으므로 유동적인 구조이다. 또한 중복되는 데이터가 존재해도 상관이 없다.

List 인터페이스를 구현한 주요 클래스로는 ArrayList, Vector, Stack, LinkedList가 존재한다.

이 중 ArrayList와 Vector 클래스의 사용법은 거의 동일하고, 기능도 비슷한 반면 ArrayList는 Thread safe하지 않고 Vector는 Thread safe하다.

> Set

Set은 순서를 고려하지 않으며, 원하는 값이 포함되어 있는지를 확인할 때 주로 사용한다. 또한 중복되는 값을 무시한다.

Set 인터페이스를 구현한 주요 클래스로는 HashSet, TreeSet, LinkedHashSet이 있다.

>> HashSet

순서가 전혀 필요 없는 데이터를 해시 테이블에 저장하며, 성능이 가장 좋다.

>> TreeSet

저장된 데이터의 값에 따라 정렬되는 셋이며, HashSet에 비해 약간 성능이 느리다.

>> LinkedHashSet

연결된 목록 타입으로 구현된 해시 테이블에 데이터를 저장하며, 저장된 순서에 따라 값이 정렬된다. 성능은 제일 좋지 않다.

> Map

모든 데이터가 키(key)-값(value) 쌍으로 이루어져 있으며, 키 or 값 없이 저장될 수 없는 자료구조이다.

이때, 키는 해당 Map에서 고유해야 하는 반면 값은 중복되어도 상관 없다.

![image](https://user-images.githubusercontent.com/103405457/232741150-0fdfe26d-d15c-41e0-9346-ff12d8fab180.png)

>> HashMap

키나 값에 null 값을 저장할 수 있으나 여러 Thread에 safe 하지 않다.

>> Hashtable

키나 값에 null 값을 저장할 수 없지만 여러 Thread에 safe 하다.

## List vs Set

List는 데이터를 검색할 때, 데이터를 순서대로 처리해야하므로 0번 째부터 하나씩 찾아봐야 한다.

반면 Set은 데이터를 검색할 수 있기 때문에 보다 빠르게 데이터를 검색할 수 있다.

## ArrayList, LinkedList란 무엇이며 둘 중 어떤 것이 성능이 더 좋은가?

- ArrayList

내부적으로 데이터를 배열에서 관리하며 데이터의 추가 및 삭제를 임시 배열을 생성해 데이터를 복사하는 방법을 사용한다.

- LinkedList

데이터를 담고 있는 노드들이 연결되어 있으며 노드의 포인터가 다음이나 이전의 노드와의 연결을 담당한다.

즉, 순차적으로 데이터를 추가 및 삭제하는 경우 ArrayList가 빠르지만 순서에 상관없이 중간에 있는 데이터를 추가 및 삭제하는 경우 LinkedList가 더 빠르다.

## Stack vs Queue

Stack은 LIFO(Last-In First-Out)인 반면 Queue는 FIFO(First-In First-Out)이다.

# [자바의 신] 25장

## Process, Thread란 무엇인가?

### context swiching이란?

## 동시성 vs 병렬성

### Syncronized란?

#### Critical Section이란?

#### Mutex, Spin Lock이란?
