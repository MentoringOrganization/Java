## ArrayList와 LinkedList의 장단점을 비교하라
ArrayList의 경우 내부적으로 배열로 구현되어있다. 반면 LinkedList는 배열이 아닌 이전,다음 요소를 참조하는 형태로 구현되어 있다.
ArrayList와 LinkedList는 몇가지 장단점을 가지고있다.
1. ArrayList는 비 순차적인 접근에 더 유리하다.
   ArrayList는 인덱스를 통해 접근하는 반면, LinkedList는 노드를 따라 차례로 따라가서 접근해야하기 때문이다.
2. ArrayList는 마지막 요소가 아닌 중간에 있는 요소를 삭제해야 한다면 큰 오버헤드가 따른다.
   ArrayList는 마지막 요소를 삭제해야한다면 마지막 요소를 null로 바꾸면 끝이다. 반면, 그 외의 요소를 삭제한다면 뒤에 있는 요소들을 한 칸씩 당겨와야 해서 오버헤드가 크다. 반면 LinkedList는 참조만 변경하면 되기 때문에 중간에 있는 요소를 삭제하더라도 빠르게 삭제가 가능하다.
3. ArrayList는 배열의 크기보다 많은양의 요소를 추가할 때, 오버헤드가 크다.
   ArrayList가 가진 배열의 크기를 넘어설 때, ArrayList는 배열의 크기를 두배로 늘리고 기존 배열의 요소들을 복사해온다. 반면, LinkedList는 새로운 요소를 마지막 요소의 next가 가리키게만 하면 되므로 요소를 쉽게 추가할 수 있다.
## HashSet과 TreeSet의 차이를 설명하라
HashSet은 내부적으로 hash table에 저장되는 반면, TreeSet은 red-black tree구조로 저장된다. **모르겠다 ^^**

## Stack을 구현할 때는 주로 ArrayList, Queue를 구현할 때는 주로 LinkedList를 사용하여 구현한다. 그 이유를 설명하라.
ArrayList는 마지막 요소를 삭제할 때, 속도가 빠르다. 반면, Queue는 처음 요소를 삭제할 때, ArrayList에 비해 속도가 빠르다.

### Stack이 사용되는 사례와 Queue가 사용되는 사례를 하나씩 소개하고 왜 그것의 구현에 Stack혹은 Queue가 적합한지 설명하라.
Stack의 예시로는 웹브라우저의 뒤로가기/앞으로가기가 있다. Queue의 예시로는 인쇄 작업 대기 목록이 있다.
웹 브라우저의 뒤로/앞으로를 먼저 생각해보자. 이 기능을 위해선 두개의 Stack이 필요하다. 하나는 "뒤로 Stack", 다른 하나를 "앞으로 Stack"이라 칭하겠다. 페이지에 접속하면 이전 페이지가 뒤로 Stack에 저장된다. Stack이기 때문에 최근에 접속한 페이지가 가장 위에 저장되어 있다. 뒤로가기를 누를 시, 현재 페이지는 앞으로 Stack에 저장되고 뒤로 Stack에서 페이지를 가져온다. 앞으로를 누를 시, 현재페이지는 뒤로 Stack에 저장되고 앞으로 Stack에서 페이지를 가져온다.
인쇄 작업 대기 목록을 생각해보자. 인쇄요청을 하면 인쇄 작업 대기목록에 요청한 순서대로 저장된다. 프린터는 먼저 들어온 문서부터 하나씩 차례대로 인쇄작업을 진행하게된다. 이는 Queue로 볼 수 있다.

## Iterator와 ListIterator의 차이가 무엇인가?
Iterator는 Collection Framework를 표준화된 방식으로 순회하기 위해 사용한다. Iterator는 다음 요소로만 순회가 가능한 반면, ListIterator는 이전 요소로도 순회가 가능하다.

## Comparable과 Comparator를 비교하라.
Comparable과 Comparator는 모두 인터페이스이다. Comparable을 구현하는 클래스는 compareTo(T o)메서드를 오버라이딩 해야하며,
Comparator를 구현하는 클래스는 compare(T o1,T o2)를 오버라이딩 해야한다.
compareTo의 경우 자기 자신과 매개변수를 비교하는 반면, compare는 매개변수 끼리 비교하여 값을 리턴하는 메서드다.
Arrays.sort()를 기준으로 비교해보자. 만약 Arrays.sort()의 매개변수로 primitive type의 배열이 전달될 경우, 대소비교 연산을 하여 정렬한다. 반면, 객체의 배열이 매개변수로 전달 되면, 어떻게 대소비교를 진행할지가 명확하지 않다. 만약 객체가 comparable을 구현하였다면, compareTo메서드를 호출하여 대소비교를 진행한다. 만약 comparable을 구현하지 않은 객체라면, comparator를 구현한 객체를 매개변수로 함께 전달해줘야 한다. comparator만 구현한 익명객체를 전달하는 것이 일반적이다.

## List와 Set을 비교하라.
List는 저장되는 순서를 유지하고, 중복을 허용하는 반면,
Set은 저장되는 순서가 중요하지 않고, 중복을 허용하지 않는다.

### HashMap과 TreeMap의 차이를 설명하여라.
HashMap은 Hash table 자료구조에 따라, 데이터가 저장되는 반면에
TreeMap은 이진 검색 트리의 형태로 데이터를 저장한다. 
Hash table구조로 데이터를 저장하는 HashMap은 특정 데이터를 찾아내는 속도가 TreeMap보다 빠르다. TreeMap은 데이터를 정렬시키며 저장하기 때문에, 데이터 저장또한 Hash table이 더 빠르다. 반면, 15살 이상 30살 미만인 사람을 검색하여라. 와 같은 범위 검색의 경우는 이미 정렬되어 있는 TreeMap이 HashMap보다 탐색 속도가 더 빠르다.

## Generics를 사용하는 이유가 무엇인가? 그냥 매개변수로 Object를 넘기는 것과 무엇이 다른가?

## Load Factor에 대해 설명하여라.













## QFM

### List인터페이스를 구현한 클래스는 책에나오는 ArrayList,LinkedList,Stack,Vector 뿐만 아니라 PersistenceList,FastList,IdentityLinkedList,AbstractImmutableList,SynchronizedList,UnmodifiableList,CopyOnWriteList등등 진짜 엄청 많다.Set과 Map도 마찬가지던데 이러한 클래스들은 잘 사용되지 않아서 책에서 소개를 안한건지? 아니면 이러한 클래스들도 현업에서 자주 쓰이는 클래스들인지. 그래서 저 자료구조들도 모두 하나씩 공부해봐야 하는건지, 공부를 해야한다면 지금시점에 바로 공부를 하는게 맞을지 나중에 필요할 때, 공부하는게 맞는지. 공부의 우선순위가 어느정도인건지 가 궁금합니다.

