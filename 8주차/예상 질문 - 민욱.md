# 💡 (9주차) 자바 예상 질문 정리

# 📜 이전 복습

## String a="a"; String b="b"; String c=a+b;와 같이 String클래스는 "+"를 사용해서 문자열을 결합하는 것은 비효율적인 작업이 수반된다. 이를 설명하여라.

### 연산을 통해 문자열 결합이 필요한 경우 String을 대신해 어떤 클래스를 사용하는 것이 좋은가?**

### StringBuffer와 StringBuilder는 어떤 차이가 있는가?

##  문자열 리터릴(String Literal)이란 무엇인가?

### 문자열 리터럴은 JVM의 어디에 저장되는가?

## try-catch-finally가 어떤 이유로 생긴 문법인지 설명하라.

## Enum이 무엇이고 언제 사용될 수 있는지 설명하라.

## String의 intern()메서드를 설명하라

### String의 intern()메서드는 사용을 자제하라고 말한다. 그 이유가 무엇인가?
# 📚 예습

## 자바 8에서 interface 스펙에 변화가 생겼다. 어떤 변화가 생겼는지 설명하라.
Java 8에서는 default method가 추가되었다. default method란 원래 기존 interface에서는 인터페이스에는 추상 메서드 밖에 존재할 수 없었고 구현된 메서드는 존재할 수가 없었다. 하지만 자바 8부터는 default method라는 이름으로 구현된 메서드를 만들 수 있게되었다.

### 왜 그런 변화가 생겼는가?
interface에 구현된 메서드가 존재할 수 없으면 수정해야 하는 부분이 너무 많아지기 때문이다. 해당 interface를 수정하고싶으면 해당 인터페이스를 구현하고있는 모든 클래스에 수정이 들어갔어야 했는데 이것은 shootgun survey로 볼 수 있을거 같다. 해당 부분을 피하기위해 사용되는 것이 default method이다.

## abstract Class가 무엇인지 설명하라.
abstract Class란 추상 클래스로서 구현하지 않은 추상 메서드가 하나이상 존재해야 하는 클래스이다.

### 어떨 때 abstract Class를 사용하고 어떨 때 interface를 사용할지 설명하라.
주로 인터페이스를 선언할 때는 행위에 집중하는 편이고 추상 클래스를 선언할 대는 동일한 행위를 하되 특성이 다른 경우 사용하는 경우가 많다.
...? 잘 이해가 안간다.

## 단일 책임 원칙(SRP)을 설명하라.
단일 책임 원칙 이하 SRP는 하나의 클래스는 하나의 책임만을 가져야 한다는 원칙이다. 아래 다이어그램을 살펴보자.
![image](https://github.com/MentoringOrganization/Java/assets/46997074/55921d92-afd7-4c00-b7c0-ed21ab3ad614)

남자 클래스는 혼자서  남자친구, 아들, 사원, 소대원으로서의 역할(책임)을 가지고있다. 해당 다이어그램은 SRP를 위반한 클래스 다이어그램이다.
SRP를 지키도록 수정하면 아래와 같이 변경된다.

![image](https://github.com/MentoringOrganization/Java/assets/46997074/42e8d06d-19c9-4f74-a77f-0f14de74d9b0)

### divergent change(여러 원인에 의한 변경)를 설명하라.
divergent change는 마틴 파울러가 리펙토링책에서 설명한 code smell중 하나이다. 하나의 클래스가 여러 책임을 지고있다면 한 책임의 변화가 다른 책임까지 영향을 줄 수 있다. 앞서 살펴보았던 남자 클래스 예시를 다시 확인해보라.

남자친구 역할에 변화나 문제가 생기면 남자 클래스를 수정해야하고 아들 역할에 변화가 생겨도 남자 클래스를 수정해야한다. 그렇게 되면 해당 클래스에 엮여있는 모든 책임이 다시 컴파일 되어야 할것이다. 이는 로버트 c 마틴이 제안한 design smell중 Viscosity와 Fragility와 관련있다.

하지만 SRP를 지킨 다이어그램을 확인해보면 역할별로 클래스가 분리되어있어 남자친구 역할에 문제가 생기면 남자친구 클래스만 수정하면 된다.
### shotgun surgery(산탕총 수술)을 설명하라.
![image](https://github.com/MentoringOrganization/Java/assets/46997074/0301ad87-c868-4566-b1f5-693697b67e82)

shotgun surgery도 마틴 파울러가 리펙토링책에서 설명한 code smell이다.s위 다이어그램을 확인해 보면 남자친구,아들,회사원,소대원 클래스에 모두 전화하기 메서드가 존재한다. 전화하기 메서드에 변경이 필요하다고 생각해보자. 위에서 언급한 모든 클래스에 있는 전화하기 메서드를 수정해야 할 것이다. shotgun surgery란 이처럼 어떤 변경이 있을 때, 여러 클래스를 수정해야 하는 경우를 말한다. 
해결방법은 간단하다. 남자클래스에 전화하기 메서드를 구현하여 사용하거나 전화하기 메서드를 구현하는 별도의 클래스를 만들면된다.'

## 개방 폐쇄 원칙(OCP)를 설명하라.
> 소프트웨어 엔티티는 확장에 대해서는 개방되어야 하지만, 변경에 대해서는 폐쇄되어야 한다.
> 모듈 자체를 변경하지 않고도 그 모듈을 둘러싼 환경을 바꿀수 있어야 한다
![image](https://github.com/MentoringOrganization/Java/assets/46997074/3e847171-961a-42b3-836a-ebb16dca43ee)
![image](https://github.com/MentoringOrganization/Java/assets/46997074/4501e00c-0773-4300-8ad9-47dd36251d3a)
![image](https://github.com/MentoringOrganization/Java/assets/46997074/2c233cf2-cc10-436f-a2c3-3f9a765443fb)

두번째 문장은 첫번째 문장의 다른 말이다. 아래 다이어그램을 살펴보자.


### 개방 폐쇄 원칙이 적용될 수 있는 예시를 설명하라.

### 개방 폐쇠 원칙을 적용할 때 고려할만한 점이 뭐가있는가?

## 리스코프 치환 원칙(LSP)를 설명하라.
![image](https://github.com/MentoringOrganization/Java/assets/46997074/6574fb3f-0bec-44a5-a812-b4ee4b7e0823)

### 오버라이딩 할 때, 접근 제어자는 조상클래스의 메서드보다 좁은 범위로 변경할 수 없다. 왜 그런가?

### 오버라이딩 할 때, 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다. 왜 그런가?

### 정리글
객체지향 설계 원칙에 대해 여러 글들을 읽고 블로그에 정리했으니 한번 읽어보셔도 좋을거같아요..ㅎ
https://ayaan-dev.tistory.com/14
## Adapter패턴이 무엇이고 왜 사용하는가?

### Adapter패턴의 구현방식을 설명하라.

### Adapter패턴에 녹아있는 설계원칙은 무엇이 있는가?

### Adapter패턴이 사용되는 예시를 설명하라.

## Proxy 패턴이 무엇인가?

### Proxy 패턴의 종류엔 무엇이있는지 3개이상 제시하고 각각이 어떤 개념인지 설명하라.

### Proxy 패턴이 실제로 사용되는 예시를 설명하라.

## Decorator 패턴이 무엇인지 설명하라

### Decorator 패턴과 Proxy 패턴의 차이를 설명하라.

## Singleton 패턴을 설명하라.

### 아래는 고전적인 Singleton 패턴의 구현 코드이다. 해당 코드의 문제점을 설명하라.
```
public class Singleton{
    private static Singleton uniqueInstance;	// 유일한 인스턴스를 저장하기위한 클래스 변수
    
    private int var1;
    private int var2;
    
    private Singleton(){ // 외부에서 생성자를 호출하지 못하게 하기위해 접근 제어자를 private으로 설정하였다.
    	var1=0;
        var2=0;
    }	
    
    public static Singleton getInstance(){
    	if(uniqueInstance ==null){	// 아직 생성된 인스턴스가 없는지를 확인하고 없다면 인스턴스를 생성한다.
        	uniqueInstance = new Singleton();
        }
        
        return uniqueInstance; // 이미 생성된 인스턴스가 있다면 이미 생성되어있는 인스턴스를 반환한다.
    }

}
```

### 아래는 흔히 알려진 메서드에 synchronized키워드를 사용하는 방식이다. 해당 방식의 문제점을 설명하라.
```
public class Singleton {
	private static Singleton uniqueInstance;
    
    private Singleton(){}
    
    public static synchronized Singleton getInstance(){ //synchronized 설정
    	if( uiqueInstance == null){
        	uniqueInstance=new Singleton();
        }
        
        return uniqueInstance;
    }
    
    ...
}
```

### 위 방법의 문제점을 해결할 수 있는 대안을 제시하라.
