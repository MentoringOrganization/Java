# 💡 (9주차) 자바 예상 질문 정리

## [자바의 신]

## 1. 자바에서 예외의 종류에 대해 설명해보자.

### 예외와 에러에는 어떤 차이가 있을까?

## 2. 예외를 처리하기 위한 구문으로는 try-catch-finally가 있다. 어떤 식으로 쓰는가?

### catch에서 return을 한다면 finally에 있는 코드는 실행될까?

## 3. Inner Class에 대해 설명하자.

### Inner Class와 Nested Class의 차이는?

## 4. 익명 클래스는 무엇일까?

### 주로 어떤 경우에 사용할까?

## [자바 객체지향의 원리와 이해]

## 1. 추상 클래스는 어떨 때에 사용하게 되는가? ▶ 추상 클래스 및 메소드의 특징을 말해보자.

- 쥐, 고양이, 병아리가 상속받은 동물 클래스 - 객체의 경우 어떻게 울어야 하지? / 누가 실수로 동물 객체를 만들면 어떡하지?
- 동물 참조 변수 배열로 모든 동물을 울게 하려면 하위 클래스에서 오버라이딩할 울어보세요() 메소드가 동물 클래스에 필요한데...

▶ 추상 클래스는 인스턴스, 즉 객체를 만들 수 없다. / 추상 메소드는 하위 클래스에게 메소드의 구현을 강제한다. / 추상 메소드를 포함하는 클래스는 반드시 추상 클래스여야 한다.

## 2. 생성자와 관련하여 꼭 기억해야 할 자바의 특징 2가지는?

- 개발자가 아무런 생성자도 만들지 않으면 자바는 인자가 없는 기본 생성자를 자동으로 만들어준다.
- 인자가 있는 생성자를 하나라도 만든다면 자바는 기본 생성자를 만들어 주지 않는다.

### 생성자의 원래 이름은?

객체 생성자 메소드이다.

## 3. Static 블록이 객체 멤버에 접근할 수 없는 이유는?

우선 객체 멤버는 클래스가 static 영역에 자리 잡은 후에 객체 생성자를 통해 힙에 생성된다.

따라서 클래스의 static 블록이 실행되고 있을 때에는 해당 클래스의 객체는 하나도 존재하지 않기 때문에 static 블록에서는 객체 멤버에 접근할 수 없는 것이다.

### 패키지 또는 클래스는 어느 시점에 로딩되는가?

해당 패키지 또는 클래스가 처음으로 사용될 때 로딩된다.

### 클래스가 제일 처음 사용될 경우란?

- 클래스의 정적 속성(ex. static final)을 사용할 때
- 클래스의 정적 메소드를 사용할 때
- 클래스의 인스턴스를 최초로 만들 때

## 4. 아래 코드는 결과가 모두 true이다. 왜 그럴까?

```
public class Driver {
  public static void main(String [] args) {
    동물 동물객체 = new 동물 ();
    동물 조류객체 = new 조류 ();
    동물 펭귄객체 = new 펭귄 ();
    
    System.out.println(동물객체 instanceof 동물);
    System.out.println(조류객체 instanceof 동물);
    System.out.println(조류객체 instanceof 조류);
```

객체 참조 변수의 타입이 아닌 실제 객체 타입에 의해 처리되기 때문이다.

## 5. 아래 코드는 객체 메소드를 호출할 때 코드이다. 실행 시 JVM에 의해 어느 부분이 어떻게 바뀌는지, 그리고 왜 그렇게 되는지에 대해 말해보자.

```
class 펭귄 {
  void test() {
    System.out.println("Test");
  }
}

public class Driver {
  public static void main(String[] args) {
    펭귄 뽀로로 = new 펭귄();
    
    뽀로로.test();
   }
}
```

정답 코드는 아래와 같다.

```
class 펭귄 {
  void test(펭귄 this) {
    System.out.println("Test");
  }
}

public class Driver {
  public static void main(String[] args) {
    펭귄 뽀로로 = new 펭귄();
    
    // 클래스명.객체메소드명()
    // 또한 test 메소드 호출 시, 객체 자신을 나타내는 this 객체 참조 변수를 넘긴다.
    펭귄.test(뽀로로);
   }
}
```

객체 멤버 메소드는 각 객체별로 달라지는 것이 아니라, 객체 멤버 메소드에서 사용하는 객체 멤버 속성의 값만 다를 뿐이다. 그렇기에 똑같은 객체 멤버 메소드인 test() 메소드를 힙 영역에 여러 개 만드는 것은 메모리 낭비이므로, JVM은 객체 멤버 메소드(여기선 test())를 static 영역에 단 하나만 보유한다.

## 6. SOLID의 I에 해당하는 ISP(인터페이스 분리 원칙)란?

> 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.
> > ex. 남자 클래스와 남자친구 인터페이스, 아들 인터페이스, 사원 인터페이스, 소대장 인터페이스

즉, 큰 범주를 가지는 하나의 클래스를 두고, 이를 각각의 역할에 따라 인터페이스로 분할하여 해당 역할에 따른 제한을 두는 원칙이다.

### 위 원칙과 유사한 SOLID의 다른 원칙은?

단일 책임 원칙(SRP)이다.

단일 책임 원칙은 하나의 클래스를 각각의 역할에 맞게 클래스를 더 세분화한 반면, 인터페이스 분리 원칙은 하나의 클래스를 둔 채 각각의 역할에 맞게 인터페이스를 세분화하여 구현한 것이다.

### (🔥) 왜 특별한 경우가 아니라면 단일 책임 원칙을 적용하는 것이 더 좋은 해결책일까?

### 인터페이스 최소주의 원칙이란?

인터페이스를 통해 메소드를 외부에 제공할 때는 최소한의 메소드만 제공하라는 것이다.

이를 따를 경우, 해당 메소드를 사용할 수 없을 경우나 불필요한 형변환이 발생하는 경우는 없다.

또한, 추가로 인터페이스는 그 역할에 충실한 최소한의 기능만 공개하는 것이 좋다.

## 7. SOLID의 D에 해당하는 DIP(의존 역전 원칙)란?

> 고차원 모듈과 저차원 모듈 모두 다른 추상화된 것에 의존해야 한다.
> 구체적인 것이 추상화된 것에 의존해야 한다.
> 자주 변경되는 구체 클래스에 의존하지 마라.

즉, 하위 클래스나 구체 클래스가 아닌 변하지 않을 가능성이 높은 상위 클래스, (추상화된) 인터페이스, 추상 클래스를 통해 의존하라는 원칙이다.

### 위 원칙과 유사한 SOLID의 다른 원칙은?

개방 폐쇄 원칙(OCP)이다.

## 8. SoC(Separation Of Concerns, 관심사의 분리)란?

> 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모으고, 관심이 다른 것은 가능한 따로 떨어져 서로 영향을 주지 않도록 분리하라.
> 하나의 속성, 하나의 메소드, 하나의 클래스, 하나의 모듈 또는 하나의 패키지에는 하나의 관심사만 들어 있어야 한다.

관심사가 다르고, 변화의 시기가 다르면 분리해야 한다는 개념이다.

## 9. SOLID란 무엇이며 각각의 원칙들에 대하여 한 줄 요약을 해보자.

### SRP(단일 책임 원칙)

어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이다.
> ex. 속성이 단일 책임 원칙을 지키지 못하는 경우, 하나의 속성이 여러 의미를 갖는 경우
> > 남자 클래스 뿐만 아니라 여자 클래스도 군번 속성을 가질 수 있는 경우, 강아지 클래스의 소변 메소드가 수컷 강아지의 행위와 암컷 강아지의 행위를 모두 구현하려고 할 경우

### OCP(개방 폐쇄 원칙)

자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.
> ex. 자동차와 같은 상위 클래스 또는 인터페이스를 중간에 둠으로써 자동차 입장에서는 자신의 확장에 개방되어 있으며, 운전자 입장에서는 주변의 변화에 폐쇄돼 있다.

### LSP(리스코프 치환 원칙)

서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
> ex. 동물 분류도

### ISP(인터페이스 분리 원칙)

클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.
> ex. 남자 클래스와 남자친구 인터페이스, 아들 인터페이스, 사원 인터페이스, 소대장 인터페이스

### DIP(의존 역전 원칙)

자신보다 변하기 쉬운 것에 의존하지 마라.
> ex. 스노우타이어, 일반타이어, 광폭타이어 클래스는 타이어 인터페이스에 의존해야 한다.
