## Servlet의 Filter가 무엇인지 설명하라.
아래 요청이 처리되는 과정을 살펴보라.

(image 위치)

Filter는 WAS에 요청이 들어오고 Dispatcher Servlet에 도달하기 이전까지의 구간에서 작동한다. Filter는 체인 형식으로 여러개가 이어질 수 있다.
일반적으로 로그를 남기는 경우나 로그인체크를 해야하는 경우에 주로 사용된다.

```
ublic interface Filter {
    
    public default void init(FilterConfig filterConfig) throws ServletException {}
    
    public void doFilter(
        ServletRequest request,
        ServletResponse response,
        FilterChain chain
        ) throws IOException, ServletException;
    
    public default void destroy() {}
}
```
상단의 Filter Interface에는 3개의 메서드가 선언되어 있다.

- init()     : 필터 초기화 메서드로 서블릿 컨테이너가 생성될 때 호출된다.
- doFilter() : 고객의 요청이 올 때 마다 해당 메서드가 호출된다. 해당 메서드에 필터의 로직을 구현한다.
- destroy()  : 필터 종료 메서드로 서블릿 컨테이너가 종료될 때 호출된다. 주로 자원을 반납하는 로직이 들어간다.

### FilterRegisterationBean이 하는 역할을 설명하라.
FilterRegistrationBean은 Filter를 등록하는 역할을 수행하는 객체이다. Filter Chain 중에서 몇 번째에 위치할지, 어떤 urlPattern에 매칭할지를 결정할 수 있다.

### ComponentScan을 통해 Filter를 등록할 수도 있지만 주로 Config파일에 @Bean으로 등록하는 형식을 사용하는데 그 이유가 무엇일까?
@ServletComponentScan을 이용하면 Filter를 등록할 수 있지만 필터 순서를 조절할 수 없다. 따라서 Config파일안에 FilterRegisterationBean을 이용해 등록하는 것이 일반적이다.

### Spring의 Intercepter가 무엇인지 설명하라.
Filter와 거의 유사하지만 Spring에서 제공해주는 기술이다. Filter와 마찬가지로 Chain형태로 구성할 수 있으며, 로그인, 로그에 사용된다.
```
    public interface HandlerInterceptor {
        
        default boolean preHandle(
            HttpServletRequest request,
            HttpServletResponse response,
            Object handler
        ) throws Exception {}

        default void postHandle(
            HttpServletRequest request,
            HttpServletResponse response,
            Object handler,
            @Nullable ModelAndView modelAndView
        ) throws Exception {}
        
        default void afterCompletion(
            HttpServletRequest request,
            HttpServletResponse response,
            Object handler,
            @Nullable Exception ex
        ) throws Exception {}
    }
```

(이미지)

- preHandle       : 컨트롤러 호출 전에 호출된다. preHandle의 응답값이 true이면 다음으로 진행하고, false면 더는 진행하지 않는다.
- postHandle      : 컨트롤러 호출 후에 호출된다.
- afterCompletion : 뷰가 렌더링 된 이후에 호출된다.

### postHandle과 afterCompletion은 호출 흐름에서 어떤 차이가 있는지 말하라.
(이미지)
afterCompltion은 뷰가 렌더링 된 이후에 호출되지만 어차피 Controller가 호출된 이후라는 시점에서 큰 차이는 없다. 그보다 더 큰 것은 postHandle은 예외가 발생했을 때 호출되지 않지만 afterCompletion은 예외가 발생했어도 똑같이 호출된다는 차이가 있다.

### Spring의 Intercepter는 Filter와 무엇이 다른가?
Filter는 Servlet에서 제공하는 기술이고 Intercepter는 Spring에서 제공하는 기술이다. Filter와 Intercepter는 적용되는 시점에서 차이가 난다.
(이미지)
Filter는 Dispatcher Servlet이 호출되기 전, Intercepter는 Dispatcher Servlet이 호출된 이후에 작동한다. 하지만 Dispatcher Servlet은 어떤 메서드를 구현했느냐에 따라 작동 시점을 더 세밀하게 조절 가능하다는 차이가 있다.
Filter와는 다르게 Dispatcher Servlet은 예외 URL Pattern도 제공해주며 URL Pattern을 지정할 때 표현식을 통해 매우 정밀하게 지정할 수 잇다.

https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/util/pattern/PathPattern.html

### Login을 구현하고자 할 때 어떤 것을 사용하겠는가?
Filter를 사용하든, Intercepter를 사용하든 크게 상관은 없으나 일반적으로 로그인상태에서만 요청할 수 있는 api가 있고 로그인 하지않아도 요청할 수 있는 api가 있으므로 Intercepter를 사용하는 것이 편할 것으로 생각된다. Filter를 사용하면 로그인하지 않아도 요청할 수 있는 URL을 따로 저장해두고 확인하는 로직을 doFilter()안에 넣어야하지만 Intercepter는 excludePathPatterns()메서드를 통해 등록할 때 지정할 수 있으므로 구현이 간편하다는 장점이 있다. 사실 로그인이 아니더라도 Filter가 제공해주는 모든 기능은 Intercepter도 제공하고 있으며 추가로 더 세밀한 지정이 가능하다는 장점이 있어 최근에는 Filter보다는 Intercepter를 주로 사용한다.

## HandlerExceptionResolver가 무엇인지 설명하라.

### ExceptionResolver가 무엇인지 설명하라.

### @ExceptionHandler란?

### @ControllerAdvice란?