# 💡 (10주차) 자바 예상 질문 정리

## [자바 객체 지향의 원리와 이해]

## [스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술]

## 1. 스프링 삼각형 3요소 중 하나인 IoC/DI란?

## 2. IoC(Inversion of Control)

### 프로그래밍에서의 의존성이란?

프로그래밍에서 의존 관계는 new로 표현된다.

아래의 예시를 보자.

> ex. A 클래스가 B 클래스에 의존하고 있는 경우
```
class A {
    void someMethod() {
        B b = new B();
        b.doSomething();
    }
}
```
객체지향 프로그래밍에서 **A 클래스가 B 클래스의 객체를 생성('new B()')하고 사용한다는 것은 A 클래스가 B 클래스의 특정 메소드나 속성에 의존**하고 있다는 의미이다. 즉, A 클래스의 기능이 B 클래스의 기능이나 상태에 어떤 방식으로든 연결되어 있다.

위 코드를 통해 살펴보자면, A 클래스의 someMethod() 메소드는 B 클래스의 doSomething() 메소드의 동작이 바뀌거나, 그 메소드가 더 이상 존재하지 않게 되면 A 클래스의 someMethod() 메소드는 제대로 동작하지 않게 된다.

위 내용을 통해 의존성, 즉 IoC(Inversion of Control)를 설명할 수 있다.

## 3. DI(Dependency Injection)

**객체 의존관계를 외부에서 넣어주는 개념**으로서 의존성 주입이라고 한다.

DI에는 필드 주입, setter 주입, 생성자 주입의 3가지 방법이 존재하며 대표적으로 스프링에서는 스프링 빈을 등록하는 방법 2가지로 확인할 수 있다.

### 1. 컴포넌트 스캔과 자동 의존관계 설정 = 생성자를 통한 의존성 주입

> ex. @Component 및 @Autowired
>> Controller.java
```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {

	/**
	 * The value may indicate a suggestion for a logical component name,
	 * to be turned into a Spring bean in case of an autodetected component.
	 * @return the suggested component name, if any (or empty String otherwise)
	 */
	@AliasFor(annotation = Component.class)
	String value() default "";

}
```

> ex. 파생된 @Service, @Repository, @Controller 및 @Autowired
>> MemberController.java
```
package flab.hellospring.controller;

import flab.hellospring.service.MemberService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class MemberController {
    private final MemberService memberService;

    // Controller와 Service 연결
    // memberController(객체)가 생성될 때, 스프링 빈에 등록된 memberService 객체를 넣어줌
    @Autowired
    public MemberController(MemberService memberService) {
        this.memberService = memberService;
    }
}
```
![image](https://github.com/MentoringOrganization/Java/assets/103405457/6433d514-2ae7-483e-900c-3e0a57b25419)

위와 같이 생성자 주입 방식은 의존 관계가 실행 중에 동적으로 변하는 경우는 거의 없으므로 실제 실무에서 권장되는 방식이다.

또한 @AutoWired를 통한 DI는 스프링이 관리하는 객체(위 코드에서는 memberService)에서만 동작한다. 즉, 스프링 빈으로 등록하지 않고 직접 생성한 객체에서는 동작하지 않는다.

이 밖에도 속성을 통한 의존성 주입, XML 파일을 사용한 의존성 주입, 스프링 설정 파일에서 속성 주입 등의 방법이 있다.

### 2. 자바 코드로 직접 스프링 빈 등록하기

>> SpringConfig.java
```
package flab.hellospring;

import flab.hellospring.repository.MemberRepository;
import flab.hellospring.repository.MemoryMemberRepository;
import flab.hellospring.service.MemberService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 스프링 빈에 직접 등록
@Configuration
public class SpringConfig {

    @Bean
    public MemberService memberService() {
        // 스프링 빈에 등록된 memberRepository를 넣어줌 = @Autowired
        return new MemberService(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository() {
        // 인터페이스가 아닌 구현체 객체를 생성
        return new MemoryMemberRepository();
    }
}
```

위 방법은 스프링 설정 파일을 만든 후, 스프링 빈의 생성 및 등록에 관한 설정을 작성한 코드이다. 

즉, 위 클래스의 메소드들은 빈 객체를 생성하고 해당 빈들 사이의 의존 관계를 설정하는 코드로써 동일하게 의존성 주입이 개념이 적용된 것을 볼 수 있다.

정리하자면, 실무에서는 생성자를 통해 의존성을 주입하는 것을 권장하며 주로 정형화된 컨트롤러/서비스/리포지토리 같은 코드는 컴포넌트 스캔을 사용한다. 그리고 정형화 되지 않거나, 상황에 따라 구현 클래스를 변경해야 하면 설정을 통해 스프링 빈으로 등록한다.

## 4. AOP(Aspect Oriented Programming)이란?

AOP는 **관점 지향 프로그래밍**으로서, 어떤 로직을 기준으로 핵심적인 관점과 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 모듈화를 진행한다는 개념이다.

즉, **공통 관심 사항(cross-cutting concern) vs 핵심 관심 사항(core concern)의 분리**로 이해할 수 있다.

스프링에서 AOP는 다음과 같다.
![image](https://github.com/MentoringOrganization/Java/assets/103405457/21bc42b2-1136-4c38-ac33-ec387e412cba)

>> TimeTraceAop.java
```
package hello.hellospring.aop;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component
@Aspect
public class TimeTraceAop {
    @Around("execution(* hello.hellospring..*(..))")
    public Object execute(ProceedingJoinPoint joinPoint) throws Throwable {
        long start = System.currentTimeMillis();
        System.out.println("START: " + joinPoint.toString());
        try {
            return joinPoint.proceed();
        } finally {
            long finish = System.currentTimeMillis();
            long timeMs = finish - start;
            System.out.println("END: " + joinPoint.toString()+ " " + timeMs +
                    "ms");
        }
    }
}
```

위 과정은 회원 가입, 회원 조회 등 핵심 관심 사항(core concern)과 시간을 측정하는 공통 관심 사항(cross-cutting concern)을 분리하였으며 시간을 측정하는 로직을 별도의 공통 로직으로 만들었다.

위 클래스(파일)를 생성함으로써 다음과 같은 장점이 존재한다.

- 핵심 관심 사항을 깔끔하게 유지할 수 있다.
- 변경이 필요하면 이 로직만 변경하면 된다.
- 원하는 적용 대상을 선택할 수 있다.

![image](https://github.com/MentoringOrganization/Java/assets/103405457/52fa119a-092f-41f7-8d27-e302e2accdd2)

## [스프링 핵심 원리 - 기본편]
