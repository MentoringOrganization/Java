# 💡 (10주차) 자바 예상 질문 정리

## [자바 객체 지향의 원리와 이해]

## [스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술]

## 1. 스프링 삼각형 3요소 중 하나인 IoC/DI란?

## 2. IoC(Inversion of Control)

### 프로그래밍에서의 의존성이란?

프로그래밍에서 의존 관계는 new로 표현된다.

아래의 예시를 보자.

> ex. A 클래스가 B 클래스에 의존하고 있는 경우
```
class A {
    void someMethod() {
        B b = new B();
        b.doSomething();
    }
}
```
객체지향 프로그래밍에서 **A 클래스가 B 클래스의 객체를 생성('new B()')하고 사용한다는 것은 A 클래스가 B 클래스의 특정 메소드나 속성에 의존**하고 있다는 의미이다. 즉, A 클래스의 기능이 B 클래스의 기능이나 상태에 어떤 방식으로든 연결되어 있다.

위 코드를 통해 살펴보자면, A 클래스의 someMethod() 메소드는 B 클래스의 doSomething() 메소드의 동작이 바뀌거나, 그 메소드가 더 이상 존재하지 않게 되면 A 클래스의 someMethod() 메소드는 제대로 동작하지 않게 된다.

위 내용을 통해 의존성, 즉 IoC(Inversion of Control)를 설명할 수 있다.

## 3. DI(Dependency Injection)

**객체 의존관계를 외부에서 넣어주는 개념**으로서 의존성 주입이라고 한다.

DI에는 필드 주입, setter 주입, 생성자 주입의 3가지 방법이 존재하며 대표적으로 스프링에서는 스프링 빈을 등록하는 방법 2가지로 확인할 수 있다.

### 1. 컴포넌트 스캔과 자동 의존관계 설정 = 생성자를 통한 의존성 주입

> ex. @Component 및 @Autowired
>> Controller.java
```
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Component
public @interface Controller {

	/**
	 * The value may indicate a suggestion for a logical component name,
	 * to be turned into a Spring bean in case of an autodetected component.
	 * @return the suggested component name, if any (or empty String otherwise)
	 */
	@AliasFor(annotation = Component.class)
	String value() default "";

}
```

> ex. 파생된 @Service, @Repository, @Controller 및 @Autowired
>> MemberController.java
```
package flab.hellospring.controller;

import flab.hellospring.service.MemberService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

@Controller
public class MemberController {
    private final MemberService memberService;

    // Controller와 Service 연결
    // memberController(객체)가 생성될 때, 스프링 빈에 등록된 memberService 객체를 넣어줌
    @Autowired
    public MemberController(MemberService memberService) {
        this.memberService = memberService;
    }
}
```
![image](https://github.com/MentoringOrganization/Java/assets/103405457/6433d514-2ae7-483e-900c-3e0a57b25419)

위와 같이 생성자 주입 방식은 의존 관계가 실행 중에 동적으로 변하는 경우는 거의 없으므로 실제 실무에서 권장되는 방식이다.

또한 @AutoWired를 통한 DI는 스프링이 관리하는 객체(위 코드에서는 memberService)에서만 동작한다. 즉, 스프링 빈으로 등록하지 않고 직접 생성한 객체에서는 동작하지 않는다.

이 밖에도 속성을 통한 의존성 주입, XML 파일을 사용한 의존성 주입, 스프링 설정 파일에서 속성 주입 등의 방법이 있다.

### 2. 자바 코드로 직접 스프링 빈 등록하기

>> SpringConfig.java
```
package flab.hellospring;

import flab.hellospring.repository.MemberRepository;
import flab.hellospring.repository.MemoryMemberRepository;
import flab.hellospring.service.MemberService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 스프링 빈에 직접 등록
@Configuration
public class SpringConfig {

    @Bean
    public MemberService memberService() {
        // 스프링 빈에 등록된 memberRepository를 넣어줌 = @Autowired
        return new MemberService(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository() {
        // 인터페이스가 아닌 구현체 객체를 생성
        return new MemoryMemberRepository();
    }
}
```

위 방법은 스프링 설정 파일을 만든 후, 스프링 빈의 생성 및 등록에 관한 설정을 작성한 코드이다. 

즉, 위 클래스의 메소드들은 빈 객체를 생성하고 해당 빈들 사이의 의존 관계를 설정하는 코드로써 동일하게 의존성 주입이 개념이 적용된 것을 볼 수 있다.

정리하자면, 실무에서는 생성자를 통해 의존성을 주입하는 것을 권장하며 주로 정형화된 컨트롤러/서비스/리포지토리 같은 코드는 컴포넌트 스캔을 사용한다. 그리고 정형화 되지 않거나, 상황에 따라 구현 클래스를 변경해야 하면 설정을 통해 스프링 빈으로 등록한다.

## [스프링 핵심 원리 - 기본편]
