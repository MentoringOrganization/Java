## IOC가 무엇인지 설명하라.
클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행하는 것이 일반적이다. 반면 Spring Container나 AppConfig 파일과 같은 제 3자가 객체 생성, 연결, 실행을 담당하여 흐름을 제어하는 경우를 IOC(제어의 역전)이라 부른다.

### FrameWork와 Library의 차이가 무엇인가?
내가 작성한 코드를 제어하고, 대신 실행하면 그것을 프레임워크라 부른다. 즉 제어의 역전 현상이 나타나면 프레임 워크라 부른다. 반면 내가 직접 제어의 흐름을 담당할 경우 그것은 Library라 부른다.
Junit은 라이브러리가 아니라 프레임 워크라고 부른다. 개발자가 작성한 테스트 케이스를 프레임 워크가 호출하고 테스트 결과를 제공하는 방식으로 제어의 역전 현상이 나타나기 때문이다.

## AOP가 무엇인지 설명하라.
로깅과 같은 횡단 관심사 로직을 따로 분리하여 실제 비지니스 로직에 주입하는 것을 AOP라 부른다. 사실 Spring에서 AOP를 구현했을 때, 코드의 양이 상당히 길어지고 파일의 개수가 많아진다. 그럼에도 불구하고 AOP를 사용하는 이유는 한번 AOP를 잘 작성해 놓으면 모두가 편해질 뿐더러, 실제 비지니스 로직은 매우 깔끔하게 정리된다. 또한 로직이 실행되어야 하는 클래스가 자연스레 SRP를 지키게 된다는 장점이 있다.

### Spring AOP에서 Proxy Pattern이 어떻게 쓰이는지 설명하라.
AOP가 적용되어있는 객체의 메서드를 호출했다고 하자. 이때 호출되는 객체와 메서드를 각각 A, methodA()라고 나타내겠다.
클라이언트가 A.methodA()를 호출하면 실제로는 A객체를 호출하는 것이 아닌 A_Proxy.methodA()를 호출하게 된다.
A_Proxy.methodA()내부에서는 주입되어야 하는 로직과 A.methodA()가 호출되어 실행된다. 이것이 Spring AOP에서 Proxy Pattern이 쓰이는 방식이다.

## PSA에 대해 설명하라.
뭔 소리지..?

## AppConfig(DI 컨테이너)가 하는 역할을 설명하라.
객체를 생성하고, 연결하고, 실행하는 역할을 한다. 그래서 DI 컨테이너를 IOC 컨테이너라 부르기도 한다. 또한 연결(주입)하는 역할도 하다 보니 DI 컨테이너라고도 부른다.

### 이를 사용함으로서 어떤 이점을 얻었는가?
클라이언트가 객체를 생성하지 않으므로 클라이언트는 인터페이스에만 의존하는 관계를 가지게 된다. 즉 DIP를 지킨다는 장점을 가지게 된다. 구현체가 바뀌더라도 클라이언트 코드는 전혀 수정되지 않아도 되는 이점을 얻게된다. (OCP)

## @Configuration, @Bean 어노테이션이 각각 어떤 역할을 하는지 설명하라.
스프링 컨테이너가 Bean을 등록하기 위해 읽어야하는 클래스임을 나타내는 어노테이션이다. @Bean은 해당 객체를 실제로 스프링 빈으로 등록하라는 의미의 어노테이션이다.

### Spring Container, Spring Bean이 무엇인지 설명하라.
스프링 빈이란 스프링 컨테이너가 관리하는 객체를 말한다. 객체의 생성, 연결, 실행을 스프링 컨테이너가 관리하게 된다. 

## BeanFactory, ApplicationContext를 비교하라.

## Controller, Service, Repository는 일반적으로 Singleton Pattern을 적용해서 사용한다. 왜 그런가?

### Singleton Pattern을 적용해선 안되는 경우는 어떤 경우인가?

### 위 3가지 객체 말고 Singleton Pattern으로 생성하는 객체엔 어떤 것이 있는가?

### Singleton 패턴의 클래스에서 instance 변수를 사용해도 괜찮은가?

### 프로그램이 시작할 때 println은 4번만 호출된다 그 이유가 무엇인가?
```
@Configuration
public class AppConfig {

    @Bean
    public MemberService memberService() {
        System.out.println("call AppConfig.memberService");
        return new MemberServiceImpl(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository() {
        System.out.println("call AppConfig.memberRepository");
        return new MemoryMemberRepository();
    }

    @Bean
    public OrderService orderService() {
        System.out.println("call AppConfig.orderService");
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }
    @Bean
    public DiscountPolicy discountPolicy() {
        System.out.println("call AppConfig.discountPolicy");
        return new RateDiscountPolicy();
    }
}

``` 

## 생성자를 통해 DI를 구현하는 것이 속성을 통해 DI를 구현하는 것에 비해 어떤 장점을 가지는가?

## static Method를 통해 구현하는 것과 Singleton 패턴으로 구현하는 것 어떤 차이가 있는가?

## @Target, @Retention, @Documented 어노테이션들이 하는 역할을 각각 설명하라.

## Annotation Processor가 무엇인지 설명하라.

## 스프링 빈 생명주기에 대해 설명하라.

### 빈 생명주기 콜백은 무엇인가?

### @PostContruct, @PreDestory의 한계를 말하고 이를 해결하는 방법을 설명하라.

## 빈 스코프가 무엇인지 설명하라.

### 빈스코프 종류에는 무엇이 있는가?

### 프로토 타입 스코프가 쓰일 수 있는 예시를 들어라. 

### request Scope가 쓰일 수 있는 예시를 들어라.