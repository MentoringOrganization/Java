# 📜 (1주차) 자바 추가 학습 및 2주차 질문

## 1. JVM 메모리는 어떤 구조로 되어있는지, 어떤 영역들이 있고 어떤 데이터들이 저장되는지
![image](https://user-images.githubusercontent.com/103405457/231349728-0618d2d8-774d-489a-b5fe-a5ea5046bfc0.png)
- Garbage Collector(GC)

Heap 메모리 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색 후 제거한다.

- Execution Engine

Class Loader를 통해 JVM 내의 Runtime Data Area에 배치된 바이트 코드들을 명령어 단위로 읽어서 실행한다.

- Class Loader

JVM 내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하며, 런타임 시에 동적으로 클래스를 로드한다.

- Runtime Data Area

**JVM의 메모리 영역**, 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다.

![image](https://user-images.githubusercontent.com/103405457/231352031-cff1732c-fe3b-470c-ac51-ec2ce295f2d0.png)

- Method Area

모든 Thread가 공유하는 메모리 영역이며 **클래스, 인터페이스, 메서드, 필드, Static 변수 및 메서드** 등의 바이트 코드를 보관한다. 또한 숫자 리터럴부터 런타임에 확인되어야 하는 메서드 및 필드 참조에 이르기까지 여러 종류의 상수를 포함하는 런타임 상수 풀이 생성된다.

이 영역의 내용들은 프로그램 시작 전에 로드되고 프로그램 종료 시 소멸된다.

- Heap Area

new 키워드로 생성된 **객체와 배열**이 생성되는 영역이다. 또한, 메모리 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역이다.

- Stack Area

메서드 호출 시마다 각각의 스택 프레임(해당 메서드만을 위한 공간)이 생성되며 메서드 안에서 사용되는 값들을 저장한다. 또한 호출된 **메서드의 매개 변수, 지역 변수, 리턴 값 및 연산 시 일어나는 값**들을 임시로 저장한 후 메서드 수행이 종료되면 프레임별로 삭제한다. 이때 LIFO 순서로 처리된다.

- PC Register

Thread가 시작될 때 생성되며, Thread마다 하나씩 존재한다. Thread가 ~ 부분을 ~ 명령으로 실행해야할지에 대해 기록을 하는 부분으로, 현재 수행 중인 JVM 명령의 주소를 가진다.

- Native Method Stack

자바 외 언어로 작성된 Native 코드를 위한 메모리 영역이다.

## 2. static 키워드는 메모리에서 어떤 영역에 저장되는지
JVM의 Method 영역(Static 영역)에 저장된다.

## 3. 문자열 생성시 String a = new String("abc")로 생성한것과 String a = "abc"로 생성한건 어떤 차이가 있는지
실제 JVM 메모리에 할당되는 영역에 차이가 있다.

new 예약어를 통해 문자열 객체를 생성하는 경우 JVM 메모리의 Heap Area에 할당된다.

반면, 리터럴 방식("")으로 문자열 객체를 생성할 경우 JVM의 Heap Area에 위치한 문자열 상수 풀(String Constant Pool)에 할당된다.

![image](https://user-images.githubusercontent.com/103405457/231353056-2d33d9c6-5c77-4c39-9b35-a4841b4c9c9f.png)

## 4. Garbage Collector는 어떤 방식으로 동작하는지, 메모리 영역을 어떤식으로 나누어서 동작하는지
**먼저 JVM GC(Garbage Collector)는 공통적인 2단계로 나뉘어 동작한다.**

1. Stop the World
2. Mark and Sweep

추가로 Young Generation, Old Generation에서 수행되는 Minor GC와 Major GC의 동작 방식은 다음과 같다.

**Minor GC**

(작성중)

**Major GC**

1. Heap Area에 존재하는 객체들에 대해 접근 가능한지 확인
2. GC Root에서부터 시작하여 참조값을 따라가며 접근 가능한 객체들에 Mark
3. Mark 되지 않은 객체, 즉 접근할 수 없는 객체는 Sweep 대상이 되며 해당 객체들을 제거

- **GC Root 대상**

JCM 메모리의 Stack Area에 존재하는 참조 변수, Method Area의 static data, JNI에 의해 생성된 객체

- **Mark(Marking)**

GC가 어떤 객체를 사용 중인지 식별하며, 사용 중이거나 GC Root에 재귀적으로 도달할 수 있는 객체들은 활성 상태로 표시한다.

이때, Heap 메모리를 방향 그래프(directed graph)로 간주하여 깊이 우선 탐색을 수행한다.

- **Sweep(Sweeping)**

GC가 Heap Area를 순회하면서 활성 상태로 표시되지 않은 객체들의 메모리 주소를 기록한다.

- **Compact(Compacting)**

Sweep이 일어난 다음,  필요하다면 모든 Mark 상태의 객체들이 함께 이동된다. 이 단계는 조각화를 줄이고, 새 객체들에 대한 메모리 할당 성능을 증가시킨다.

**이어서 GC는 메모리 영역을 다음과 같이 나누어서 동작한다.**

![image](https://user-images.githubusercontent.com/103405457/231355895-b4a0ce94-2cfa-4d4a-b8a4-7ea7f80c32c1.png)

## 5. GC의 알고리즘은 어떤 종류가 있는지, 각각의 특성은?

## 6. GC 수행과 관련해서 stop the world라는건 어떤건지

Garbage Collection을 실행하기 위해 JVM이 자바 애플리케이션의 실행을 멈추는 작업이다.

GC가 실행될 때는 GC를 실행하는 Thread를 제외한 모든 Thread들의 작업이 중단되고, GC가 완료되면 작업이 재개된다. 즉, 모든 Thread들의 작업이 중단된다는 것은 자바 애플리케이션이 멈춘다는 의미이다.

