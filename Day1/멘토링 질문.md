# 📚 (1주차) 자바 질문 정리
## 클래스란 무엇인가? (민욱)
클래스란 상태와 행동을 가지는 자료형으로서 정의할 수 있다.

객체지향적인 설계에서는 하나의 서비스를 구성하기 위해 여러 객체들이 존재하며, 이 객체들은 하나씩의 역할을 가지고 있다. 또한 객체는 그 역할을 수행하기 위해 메소드와 상태값을 사용해 다른 객체들과 소통하며, 이러한 객체의 설계도를 클래스라고 한다.

## 객체나 클래스에서 쓰이는 변수가 어떤 종류가 있는가? (은비)
총 4가지의 변수가 존재한다.

- 지역 변수(local variables)
- 매개 변수(parameters)
- 인스턴스 변수(instance variables)
- 클래스 변수(class variables)

### 각각 어떤 차이가 있는지?
크게 변수의 위치로 구분할 수 있다.

- 지역 변수: 중괄호 내에서 선언된 변수
- 매개 변수: 메소드에 넘겨주는 변수
- 인스턴스 변수: 메소드 밖에, 클래스 안에 선언, static 예약어 X
→ 객체가 생성될 때 시작, 객체를 참조하고 있는 다른 객체가 없으면 소멸
- 클래스 변수: 메소드 밖에, 클래스 안에 선언, static 예약어 O
→ 클래스가 처음 호출될 때 시작, 자바 프로그램이 끝날 때 소멸

이때, static 키워드를 변수에 붙일 시 클래스 변수로 취급이 되어 모든 객체에서 하나의 값을 바라보게 된다.

### static 키워드가 하는 역할이 무엇인지? (은비)
객체 생성 없이 변수나 메서드를 사용할 수 있다. 즉, static 키워드를 사용하여 static 변수와 static 메서드를 생성할 수 있다. 이때 일반적으로 객체가 생성될 시 JVM의 Heap 영역에 저장되는 반면, static은 Method 영역(static 영역)에 저장된다.

따라서 static 키워드를 통해 GC(Garbage Collector)의 관리를 받지 않고 프로그램 종료 시까지 유지된다. 즉, static 키워드를 통해서 static 영역에 할당된 변수 및 메서드는 모든 객체들을 공유할 수 있다.

## JVM이 무엇인가? (은비)
Java Virual Machine(자바 가상 머신)은 자바 프로그램이 수행되는 프로세스이다.

자바 컴파일은 자바 소스 코드를 바이트 코드로 바꾼 뒤 컴파일을 수행한다. 이때, JVM이 자바 바이트 코드를 실행할 수 있는 환경을 제공한다. 따라서 자바 바이트 코드는 OS에 상관없이 자바 어플리케이션을 실행할 수 있게 된다.

## JVM 메모리 구조가 어떻게 되어있는가? (민욱+은비)
JVM 메모리 구조는 다음과 같다.

![image](https://user-images.githubusercontent.com/103405457/230783238-54994d10-401a-4f94-8f02-1a477861f833.png)

- Garbage Collector(GC)

Heap 메모리 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색 후 제거한다.

- Execution Engine

Class Loader를 통해 JVM 내의 Runtime Data Area에 배치된 바이트 코드들을 명령어 단위로 읽어서 실행한다.

- Class Loader

JVM 내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하며, 런타임 시에 동적으로 클래스를 로드한다.

- Runtime Data Area

JVM의 메모리 영역, 자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역이다.

- Method Area

모든 Threa가 공유하는 메모리 영역이며, Class, Interface, Method, Field, Static 변수 등의 바이트 코드를 보관한다.

- Heap Area

모든 Thread가 공유하며, new 키워드로 생성된 객체와 배열이 생성되는 영역이다.
또한, 메모리 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역이다.

- Stack Area

메서드 호출 시마다 각각의 스택 프레임(해당 메서드만을 위한 공간)이 생성되며 메서드 안에서 사용되는 값들을 저장한다. 또한 호출된 메서드의 매개 변수, 지역 변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장한 후 메서드 수행이 종료되면 프레임별로 삭제한다. 이때 LIFO 순서로 처리된다.

- PC Register

Thread가 시작될 때 생성되며, Thread마다 하나씩 존재한다. Thread가 ~ 부분을 ~ 명령으로 실행해야할지에 대해 기록을 하는 부분으로, 현재 수행 중인 JVM 명령의 주소를 가진다.

- Native Method Stack

자바 외 언어로 작성된 Native 코드를 위한 메모리 영역이다.

## Garbage Collector가 무엇 인가? (은비)
메모리가 부족할 때 필요가 없어진 쓰레기, 즉 Garbage들을 삭제하는 작업을 수행하는 프로그램이다.

이때, 작업 자체는 Garbage Collection이라 부른다.

## C에서는 메모리 할당과 해제를 어떻게 하는가? (민욱)
c에서는 malloc과 같은 함수에 매개변수로 할당받을 메모리의 사이즈를 지정하여 개발자가 직접 메모리를 할당받는다. 할당받은 메모리가 더이상 쓸모 없어지면 개발자는 free라는 함수를 통해 직접 메모리를 할당해제한다.

그에반해 Java에서는 new키워드를 통해 객체를 생성할 때, 메모리가 할당되며 GC가 더이상 사용하지 않는 메모리를 찾아 자동으로 할당해제를 해준다.

## Garbage Collector가 어떻게 동작하는가? (민욱)

## Primitive Type 과 Reference Type 간에 차이가 무엇인가? (민욱+은비)
JVM 구조와 관련하여 Primitive Type과 Reference Type 간의 차이를 확인할 수 있다.

![image](https://user-images.githubusercontent.com/103405457/231169901-e5144fba-fd94-4aeb-8dbe-338d6e59faf1.png)

- Primitive Type(기본 자료형)

**Stack 영역**에 변수를 선언하며, 할당된 **값 자체를 저장**한다.

- Reference Type(참조 자료형)

Stack 영역에 변수를 선언하지만, Heap 영역에 저장된 값을 가리킨다.
즉 **Stack 영역**에는 **Heap 영역**에 저장되어 있는 **값의 주소값을 저장**하고, **Heap 영역**에는 **값 자체가 저장**된다.

### 각 타입들이 JVM의 어느 영역에 선언되는가?
Primitive Type은 Stack, Reference Type은 Heap 영역에 저장된다.

### 각 타입이 왜 굳이 따로 저장되는가? (❓)

## new라는 키워드를 사용했을 때, 어떤 일이 발생하는가? (은비)
객체를 생성한다.

### 생성한다는게 메모리 입장에서는 어떤식으로 처리가 되는가?
` ex. A 클래스의 객체 생성
`
1. Class Loader에 의해 A 클래스를 Method Area에 로드한다.
2. static initiallization(A 클래스의 class variable, static initializer)가 수행된다.
3. A 클래스가 로드된 후, 객체 생성을 위해 Heap 영역에 메모리가 할당된다.
4. 객체 생성 후, A 클래스의 생성자가 호출된다.
5. 생성된 A 클래스의 객체 주소 값이 a라는 변수에 할당된다.

## Call By Value 와 Call By Reference의 차이가 무엇인가? (은비)
Call By Value는 메서드를 호출할 때 값을 넘겨준다. 이때, 메서드를 호출하는 **호출자(Caller)의 변수**와 호출 당하는 **수신자(Callee)의 파라미터**는 복사된 서로 다른 변수이다.
![image](https://user-images.githubusercontent.com/103405457/231193330-1b6f93f4-f312-4de4-a6eb-eab4c329cb1a.png)

반면 Call By Reference는 참조(주소값)을 직접 전달하며, 호출자의 변수와 수신자의 파라미터는 완전히 동일한 변수이다.
![image](https://user-images.githubusercontent.com/103405457/231193673-4c2dec03-d32d-441c-b88b-b7eaedc0280d.png)

따라서 Call By Value는 수신자의 파라미터를 수정해도 호출자의 변수에는 영향을 주지 않는 반면, Call By Reference는 메서드 내에서 파라미터를 수정하면, 그대로 원본 변수에도 반영된다는 차이가 있다.

## 자바는 Call By Value인가 Call By Reference인가? (민욱+은비)
- Call By Value

### Reference Type의 메모리 주소를 복사해서 보내는 거랑 Call By Reference 형태로 보내는 것의 차이가 무엇인가? (❗)
설명에 앞서 Call By Reference 형태로 보내는 것을 **얕은 복사**, Reference Type의 메모리 주소(값)을 복사해서 보내는 작업을 **깊은 복사**라고 생각했다.

![image](https://user-images.githubusercontent.com/103405457/231197947-ad45a3e7-846a-44f5-9334-c7f734d3177b.png)

얕은 복사란 원본 객체에 대해서 새로운 객체를 만들고 원본 객체를 참조한다. 즉, 객체가 생성될 때 메모리에 할당된 주소값을 참조한다.

반면 깊은 복사란 복사하려는 원본 객체에 대해서 새로운 객체를 만들고, 원본 객체를 대상으로 인스턴스화할 수 있는 클래스 내부의 클래스 변수(static)와 메서드(static)뿐 아니라 인스턴스 값 모두를 복사하여 원본 객체로부터 독립적인 객체를 생성한다.

즉  **얕은 복사**란 **Call By Reference**, **깊은 복사**란 **Call By Value** 라고 볼 수 있다.

## String을 선언할 때, new키워드로 선언하는 방식과 따옴표를 써서 할당하는 방식간의 차이가 무엇인가? (민욱)
### String Literal은 무엇인가?
### 두 방식이 연산을 할때도 연산되는 과정이 다르다. 어떻게 다른가?

## equals() 와 == 의 차이가 무엇인가? (은비)
두 객체를 비교할 때 equals()는 내용(contents)이 같은지 확인(값 자체를 비교)하는 반면, ==는 비교하고자 하는 대상의 주소값을 비교한다.

즉 equals()는 **동등성**, ==는 **동일성**이다.

### 동등성과 동일성의 차이는 무엇인가?
동등성은 두 객체가 같은 정보를 갖고 있는 경우를 의미하며, 변수가 참조하고 있는 객체의 주소가 서로 다르더라도 내용이 같은 것이다.

반면 동일성은 두 객체가 완전히 같은 경우를 의미하며, 주소값이 같기 때문에 두 변수가 같은 객체를 가리킨다.

## Primitive Type과 Reference Type의 기본 값이 어떤 차이가 있는가? (민욱)
Primitive Type은 선언을 하는 순간 직접 초기화를 하지 않아도 메모리 공간을 차지하고 있다. 자료형마다 다르지만 정수형 변수들은 0으로 초기화 되며, char은 '\0000'으로 초기화 된다. double,float는 0.0, boolean은 false가 기본값이다.

반면, Reference Type은 객체를 할당해주기 전까지는 아무것도 가지고 있지 않아 null 값을 가진다. null일때 Reference Type을 통해 멤머변수에 접근하려 하면 Null Pointer Error가 발생할 수 있으므로 주의해야한다.

## 클래스 생성자가 어떤 일을 하는가? (은비)
클래스를 생성한 후 객체화를 할 때 필요한 기본적인 값들을 할당받고, 실제 객체가 생성이 될 때 값을 선언한다.

## Static 키워드를 조심해서 써야하는 이유가 무엇인가? (민욱)
Static 키워드를 붙인 변수들은 모든 인스턴스가 공유한다. 따라서 해당 인스턴스에서만 고치고 싶을 경우, 의도와는 다르게 작동할 수 있어서 static키워드 사용은 조심해야한다.

### static 변수는 GC에서 수거하는가?
static 같은 경우는 모든 인스턴스가 공유하는 영역에 존재하는 값이다 보니, GC가 수거해가는 일은 없다.

### static을 사용했을 때, memory Leak이 발생할 수도 있다. 어떠한 경우에 이런 일이 발생할것인가?
만약 List같이 크기가 정해져있지 않고 계속해서 크기가 늘어날 수 있는 대상이 static변수로 선언되어 있다면 메모리 릭이 발생하기 쉽다.

## Static Block이 무엇인가? (민욱)
생성자 혹은 instance Block같은 경우는 인스턴스가 생성되는 시점에 instance value를 적절하게 초기화하기 위해서 사용한다.

반면 static Block의 경우는 class Loader가 클래스를 불러올 때, static variable들을 적절히 초기화 하기 위해 사용되는 기능이다. 주의 깊게 볼 차이점으로는 생성자나 Instance Block의 경우 인스턴스가 생성될 때 마다 실행되는 반면, Static Block은 클래스가 불러와질 때, 한번만 실행된다는 특징이 있다.

### 흔히 Static Block의 사용을 지양하라고 말하는 이유가 무엇인가?
static block은 static variable들을 적절하게 초기화 할 때, 주로 사용하게 될 것이다. 그 과정에서 다른 객체의 레퍼런스가 필요하더라도 다른 객체들의 레퍼런스를 받아오기 어렵다. 무엇보다 static block에서 어떠한 exception이 발생하였을 때, 이 예외를 처리할 수 있는 기능이 없다. 즉, static blcok 내에서 exception이 발생한다면 서비스가 다운될 가능성이 있다.

## 접근 제어자의 종류에 어떤 것이 있고 어떤 차이가 있는가? (은비)
총 4가지의 접근 제어자가 존재한다.
- public : 누구나 접근 가능
- protected : 같은 패키지 내에 있거나 상속받은 경우에만 접근 가능
- pakage-private(default) : 같은 패키지 내에 있을 때만 접근 가능
- private : 해당 클래스 내에서만 접근 가능

정리하면 public > protected > default > private 순으로 접근할 수 있다.

## 강제는 아니지만 클래스 내부에 메소드를 선언할 때, public ~ private순으로 선언하는 것이 관례이다. 이유가 무엇인가? (은비)
우리는 어떤 클래스를 사용하다가 해당 클래스의 구현을 보기 위해서 원본 코드를 살펴볼 때, 우리가 사용하는 환경인 외부에서 사용 가능한 public을 관심있게 살펴본다.

이렇듯 타인이 코드를 읽을 때, 쉽게 볼 수 있도록 편의성을 제공하기 위해서 public ~ private 순으로 선언한다.
