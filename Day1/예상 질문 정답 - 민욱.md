### Q1. JVM메모리 구조에서 Call Stack에 저장되는 데이터와 작동 방식에 대해 설명하라.

### Q2. Static Method와 Instance Method의 차이를 설명하라.
Static Method는 Instance Method와는 달리 Class가 로드되는 시점에 메모리에 함께 로드된다. 따라서 Instance가 만들어지지 않은 상황에서도 Class명.staticMethod()형태로 호출 할 수 있다. 반면 Instance Method의 경우는 인스턴스가 만들어지고 난 후에만 그 인스턴스를 통해서 호출할 수 있다.
- Q2-1. static Method내에서는 instance 변수를 사용할 수 없다. 그 이유가 무엇인가?
Static Method는 Instance없이 호출 할 수 있는 메서드이다. 따라서 Static Method가 호출되는 시점에서 Instance가 존재하는 것이 보장되지 않는다. instance Variable의 경우는 instance가 만들어질 때, 생성되는 변수이므로 Static Method가  instance variable를 사용하는 것은 금지되어있다.반대로 instance가 생성되었을 때, 클래스는 반드시 로드된 이후이므로 instance Method에서 static variable을 참조하는 것은 아무런 문제가 없다.
- Q2-2. Method를 선언할 때, Static Method로 선언할 지 instance Method로 선언할지를 결정하는 방법이 있는가?
주로 Method내에서 instance변수를 사용하지 않는다면 static으로 선언하는 것을 고려할 만 하다. 물론 경우에 따라 다르겠지만, instance변수를 사용하지 않는다는 것은 인스턴스와는 독립적으로 작동하는 메서드일 가능성이 높아 책에서 이렇게 설명하는 것으로 보인다.

### Q3. static 변수와 instance 변수의 차이점이 무엇인가?
static 변수는 인스턴스가 만들어지기 전 class Loader가 class를 로드하면 바로 사용할 수 있는 반면에 instance변수는 인스턴스가 만들어지고 나야 사용할 수 있다. 또한 static 변수는 모든 인스턴스가 공유하는 반면 instance변수는 공유되지 않는다.
- Q3-1. static 변수는 JVM 메모리 구조의 어디에 저장되고 instance변수는 JVM메모리 구조의 어디에 저장되는가?(이거 검토안한 질문이에요 아직 생각안해보셔도 돼요.. 차이가 있을거라 예상하고 만든 질문입니다.)
- Q3-2. 클래스 변수는 인스턴스가 생성되지 않아도 사용할 수 있다. 왜 그런가?
static 변수는 class Loader가 class를 로드할 때, 함께 메모리에 올라가기 때문이다. 반면 인스턴스 변수는 인스턴스가 생성될 때, 메모리가 할당되기 때문에 인스턴스가 생성되어야만 사용가능하다.

### Q4. println의 매개변수로 boolean, char, double, String, Object 등 여러가지 타입의 매개변수가 들어갈 수 있다. 어떻게 이게 가능한가?


### Q5. 가변인자란 무엇이고 어떤 이점이 있는가?
- 가변인자가 내부적으로 어떻게 처리되는지 알고있는가?
- 매개변수에 배열을 선언하는것과 가변인자로 선언하는 것에 차이가 있는가?

### Q6. Person p = new Person() 코드가 실행될 때, 메모리에서 어떤 일이 일어나는지를 차례대로 설명해봐라.

### Q7. 기본 생성자가 무엇인가?
기본 생성자란 Compiler가 매개변수를 받지 않는 생성자를 자동으로 추가해주는 것을 말한다.
- 그럼 기본생성자는 항상 생성되는가?
클래스에 아무런 생성자가 없을 때만 자동으로 추가를 해주며, 만약 다른 생성자가 있다면 개발자가 직접 생성해줘야한다.

### Q8. 초기화 블럭에는 2가지 종류가 있다. 클래스 초기화 블럭과 인스턴스 초기화 블럭인데 각각이 무엇이고 어떤 차이가 있는지 설명해보라.
- Q8-1. 생성자가 있는데 왜 인스턴스 초기화 블럭이 존재하는가?

### Q9. 상속을 사용하는 이유가 무엇인가?
- Q9-1. 클래스를 작성하는데 있어서 상속관계를 맺어줄 것인지, 포함관계를 맺어줄 것인지를 어떻게 결정하는가?

### Q10. C++에서는 다중상속을 허용하는 반면에 Java에서는 다중상속을 허용하지 않는다. 다중상속에 어떤 문제가 있어서 Java는 다중상속을 금지했는가?

### Q11. 오버라이딩 할 때, 접근 제어자는 조상클래스의 메서드보다 좁은 범위로 변경할 수 없다. 왜 그런가?(아직 저도 답을 못내린 질문입니다. 의미없는 질문일 수 있으니, 이거는 나중에 찾아보셔도 될거같아요.)

### Q12. 오버라이딩 할 때, 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다. 왜 그런가?(아직 저도 답을 못내린 질문입니다. 의미없는 질문일 수 있으니, 이거는 나중에 찾아보셔도 될거같아요.)

### Q13. final은 클래스 앞에 붙었을 때, 메서드 앞에 붙었을 때, 멤버변수나 지연변수 앞에 붙었을 때, 각기 다르게 역할을 한다. 각각 어떤 역할을 하는가?

### Q14. abastact는 클래스앞에 붙었을 때, 메서드 앞에 붙었을 때, 각기 다른 역할을 한다. 각각 어떤 역할을 하는가?

### Q15. 객체지향의 캡슐화가 무엇이고 어떤 장점이 있는가?

### Q16. Getter나 Setter를 사용하는 이유가 무엇인가?

### Q17. 생성자에 private을 붙이는 경우가 있는데 왜 붙이는 것인가?

### Q18. 다형성(Polymorphism)이 무엇인가?
- Q18-1. 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하는것이 가능한 반면에, 자손 클래스 타입의 참조변수로 조상 클래스의 인스턴스를 참조하는 것은 불가능하다. 이유가 무엇인가?

### Q19. 자손타입을 조상타입으로 형변환 하는 것을 Up-Casting, 조상타입을 자손타입으로 형변환 하는 것을 Down-Casting이라 한다. Up-casting은 형변환 생략이 가능한 반면, Down-Casting은 형변환 생략이 불가능하다. 이유가 무엇인가?


### Q20. 추상클래스란 무엇이고 어떤 장점이 있는가?(왜 사용하는가?)
- Q20-1. 일반 클래스로 선언하고 메소드는 내용없는 빈 몸통만 만들어 놓고 자손클래스에서 오버라이딩 하여 사용하면 되는데 그럼에도 왜 굳이 추상클래스로 선언하는가?

### Q21. 인터페이스란 무엇이고 왜 사용하는가?

### Q22. 인터페이스에서 Default 메소드란 무엇인가? Default 메소드는 JDK 1.8부터 추가되었다. 어떤 불편한 점을 해결하기 위해 추가되었는가?

### Q23. 에러와 예외의 차이를 설명하여라.
- Q23-1. 에러의 종류와 차이점을 설명하라.
- Q23-2. Runtime Exception과 그 외의 Exception의 차이가 무엇인가?

### Q24. 예외를 처리해야하는 이유가 무엇인가?
- Q24-1. Runtime Exception의 경우 예외처리가 강제되지 않는다. 이유가 무엇인가?

### Q25. JDK 1.7버전부터 try-with-resources문이 추가되었다. 기존 finally를 사용하는 방식에 비해 어떤 장점이 있는가?

### Q26. Object클래스의 equals()와 hashcode()는 왜 항상 같이 오버라이딩 하라 하는걸까?

### Q27. Object클래스의 clone 메소드를 오버라이딩하기 위해서는 반드시 Cloneable interface를 구현해야한다. 그 이유는 무엇인가?

### Q28. 얕은 복사와 깊은 복사에 대해 설명해보라.
- Q28-1. clone()은 둘 중 무엇에 해당하는가?
- Q28-2. clone()이 얕은 복사라는 점 때문에 종종 의도치않은 문제가 야기되곤 한다. 어떨때, 문제가 발생하는가?

### Q29. Class 객체란 무엇인가?

### Q30. String a="a"; String b="b"; String c=a+b;와 같이 String클래스는 "+"를 사용해서 문자열을 결합하는 것은 비효율적인 작업이 수반된다. 이를 설명하여라.
- Q30-1. '+'연산을 통해 문자열 결합이 필요한 경우 String을 대신해 어떤 클래스를 사용하는 것이 좋은가?
- Q30-2. StringBuffer와 StringBuilder는 어떤 차이가 있는가?
- Q30-3. String a="a"; String b="b"; String c="c"; ...
         String str=a+b+c+d+e;와 같이 +연산자를 한줄에 결합하면 비교적 문제가 없는가..?( 위와 같은 이야기를 예전에 들어본 적이 있어요. 다만 제가볼 때, 이해가 안가는 부분이라 이것이 진실인지 찾아보려 합니다. 아직 안찾아보셔도 될거같아요)

### Q31. 문자열 리터릴(String Literal)이란 무엇인가?
- Q31-1. 문자열 리터럴은 JVM의 어디에 저장되는가?

### Q32. 오토박싱과 인박싱에 대해 설명하여라

### QFM(멘토님게 질문하고 싶은 것.)
- abstact class와 interface의 차이는 일부 메소드 구현을 허용하냐 정도 밖에 없는거 같다. 단순히 일부 메소드는 구현하길 원하는지에 따라 abstract class로 구현할지 interface로 구현할지를 결정하면 되는건가요? 하나는 class이고 하나는 interface인데 두가지의 용도가 다를거 같다고 생각되는데 딱히 그런건 없나요?
- static 초기화 블럭은 사용을 지양하라고 말씀하셨습니다. instance 초기화 블럭은 어떤가요?