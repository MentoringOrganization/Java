## Q1. JVM메모리 구조중 Call Stack 영역에 대해 설명하여라
JVM의 Call Stack은 자바 메소드 호출 시 사용되는 메모리 영역으로, 각 메소드가 호출될 때마다 해당 메소드의 지역 변수, 매개 변수 및 실행 결과와 함께 스택에 쌓이게 됩니다. 스택은 LIFO구조로 되어 있으며, 호출된 메서드는 가장 최근에 스택에 쌓인 메서드이고, 반환된 메서드는 스택의 맨 위에서 제거됩니다. 스택은 프레임 단위로 나뉘어 있으며 새로운 메서드가 호출되면 스택에도 프레임 하나가 쌓이게 되고 프레임 안에는 메서드의 매개변수, 지역 변수, 객체 참조 , 기본 자료형 변수, 메서드의 바디코드가 포함됩니다.
메서드의 바디코드가 Call Stack영역에 저장되는 것에 의문이 들 수 있는데, 메서드의 실행 코드는 Method Area에 저장되지 않으며 메서드가 실행될 때 마다 클래스 파일로부터 바이트코드를 읽어와 Call Stack에 임시 저장됩니다.
이러한 방식은 보조 메모리와의 I/O작업이 계속 필요하여 성능에 악영향을 미친다고 생각하실 수 있습니다. 이를 개선하기 위해 JVM에서는 Memory Buffer를 사용합니다. 자주 사용되는 클래스 파일은 메모리 버퍼나 Cache에 저장되어 있어 빠르게 접근이 가능합니다.

## Q2. Static Method와 Instance Method의 차이를 설명하라.
Static Method는 Instance Method와는 달리 Class가 메모리에 로딩되고 나면 실행할 수 있다. 따라서 Instance가 만들어지지 않은 상황에서도 Class명.static Method()형태로 호출 할 수 있다. 반면 Instance Method의 경우는 인스턴스가 만들어지고 난 후에만 그 인스턴스를 통해서 호출할 수 있다.

### Q2-1. static Method내에서는 instance 변수를 사용할 수 없다. 그 이유가 무엇인가?
Static Method는 Instance없이 호출 할 수 있는 메서드이다. 따라서 Static Method가 호출되는 시점에서 Instance가 존재하는 것이 보장되지 않는다. instance Variable의 경우는 instance가 만들어질 때, 생성되는 변수이므로 Static Method가  instance variable를 사용하는 것은 금지되어있다.반대로 instance가 생성되었을 때, 클래스는 반드시 로드된 이후이므로 instance Method에서 static variable을 참조하는 것은 아무런 문제가 없다.

### Q2-2. Method를 선언할 때, Static Method로 선언할 지 instance Method로 선언할지를 결정하는 방법이 있는가?
주로 Method내에서 instance변수를 사용하지 않는다면 static으로 선언하는 것을 고려할 만 하다. 물론 경우에 따라 다르겠지만, instance변수를 사용하지 않는다는 것은 인스턴스와는 독립적으로 작동하는 메서드일 가능성이 높아 책에서 이렇게 설명하는 것으로 보인다.
    
## Q3. static 변수와 instance 변수의 차이점이 무엇인가?
static 변수는 인스턴스가 만들어지기 전 class Loader가 class를 로드하면 바로 사용할 수 있는 반면에 instance변수는 인스턴스가 만들어지고 나야 사용할 수 있다. 또한 static 변수는 모든 인스턴스가 공유하는 반면 instance변수는 공유되지 않는다.

### Q3-1. static 변수는 JVM 메모리 구조의 어디에 저장되고 instance변수는 JVM메모리 구조의 어디에 저장되는가?
static 변수는 클래스가 로딩될 때, 메모리의 Method Area에 클래스 정보와 함께 저장된다. 반면에 instance 변수는 Heap 메모리 영역에 생성된다.
클래스 변수가 Method Area에 저장되는 것은 모든 인스턴스가 클래스 변수를 공유하기 때문에 클래스 정보와 함께 저장되기 위해서이다.

### Q3-2. 클래스 변수는 인스턴스가 생성되지 않아도 사용할 수 있다. 왜 그런가?
static 변수는 class Loader가 class를 로드할 때, 함께 메모리에 올라가기 때문이다. 반면 인스턴스 변수는 인스턴스가 생성될 때, 메모리가 할당되기 때문에 인스턴스가 생성되어야만 사용가능하다.

## Q4. println의 매개변수로 boolean, char, double, String, Object 등 여러가지 타입의 매개변수가 들어갈 수 있다. 어떻게 이게 가능한가?
println()은 위에서 언급한 여러 자료형에 대해 오버로딩 되어있기에 가능하다.

## Q5. 가변인자란 무엇이고 어떤 이점이 있는가?
가변인자란 매개변수로 몇 개의 인자가 들어갈 지 알 수없을 때,
매개변수에 (자료형... 이름 )으로 선언하면 내부적으로 배열을 만들어 몇개가 매개변수로 넘어 오더라도 처리할 수 있게 해주는 기능이다.
printf의 선언부는 다음과 같다. 
printf(String format, Object... args) 만약 이런 가변인자가 없다면 printf(String format,Object arg1), printf(String format,Object arg1,Object arg2)... 등 수많은 printf 오버로딩 메서드가 존재해아하며 만약 오버로딩한 개수보다 많은 수의 매개변수를 넣으려 한다면 에러가 발생할 것이다. 하지만 가변인자를 사용하면 printf(String format,Object... args)와 같이 간편하게 이를 표현할 수 있다.

### Q5-1. 매개변수에 배열을 선언하는것과 가변인자로 선언하는 것에 차이가 있는가?
사실 가변인자는 내부적으로 매개변수로 넘어온 인자들로 배열을 만들어 처리된다. printf(String format,Object[] args)로 선언해도 오버로딩 필요없이 위와 같은 방식을 만들어 줄 수 있다.  하지만 위와같이 오버로딩 한다면 Array arr=new Array(); arr.push(); arr.push(); ... printf(String format,arr); 와 같이 배열을 만들어 필요한 인자를 넣고 printf를 해야하기 때문에 불필요한 코드가 많아진다는 단점이 있다. 또한 매개변수로 배열을 선언하면 반드시 인자를 지정해 주어야한다. concatenate();는 원래는 문제가 없는 메서드지만 배열로 선언되어 있다면 에러가 발생한다.

## Q6. Person p = new Person() 코드가 실행될 때, 메모리에서 어떤 일이 일어나는지를 차례대로 설명해봐라.
1. Person 클래스 정보가 Class Loader에 의해 로딩되어 Method Area에 저장된다.
2. Static 변수의 초기화가 이루어진다.
3. Person 클래스가 로딩된 후, 인스턴스 생성을 위해 Heap영역에 메모리 할당이 이루어진다. 
4. 인스턴스 생성후, Person클래스의 생성자가 호출된다.
5. 생성된 Person 클래스의 인스턴스 주소값이 p변수에 할당된다. 

## Q7. 기본 생성자가 무엇인가?
기본 생성자란 Compiler가 매개변수를 받지 않는 생성자를 자동으로 추가해주는 것을 말한다.

### Q7-1. 그럼 기본생성자는 항상 생성되는가?
클래스에 아무런 생성자가 없을 때만 자동으로 추가를 해주며, 만약 다른 생성자가 있다면 개발자가 직접 생성해줘야한다.

## Q8. 초기화 블럭에는 2가지 종류가 있다. 클래스 초기화 블럭과 인스턴스 초기화 블럭인데 각각이 무엇이고 어떤 차이가 있는지 설명해봐라.
클래스 초기화 블럭은 Static Variable을 초기화 하는데 이용된다.
클래스 초기화 블럭은 class Loader가 해당 클래스를 메모리에 로딩한 시점에 실행된다.
클래스 초기화 블럭 내에서 Instance Variable을 사용하는 것은 금지된다. 이는 클래스 초기화 블럭이 실행되는 시점에 해당 클래스의 인스턴스가 아직 존재할 수 없기 때문이다.
반면에 인스턴스 초기화 블럭은 인스턴스가 생성될 때마다 실행되며 Static Variable도 사용할 수 있다. 이는 instance 초기화 블럭이 실행되는 시점은 Class Loader가 클래스를 메모리에 로딩한 이후기 때문에 static variable도 메모리를 할당받은 상태이기 때문에 가능하다.

### Q8-1. 생성자가 있는데 왜 인스턴스 초기화 블럭이 존재하는가?
Instance 초기화 블럭은 주로 모든 생성자에 공통으로 존재하는 코드를 뽑아내 사용한다. 이를 통해 객체지향의 중요한 특성인 코드의 중복을 피할 수 있게 해준다.

## Q9. 상속을 사용하는 이유가 무엇인가?
상속은 공통된 특성을 가진 클래스를 하나로 묶기위해 사용된다. 예를 들어, Sports Car, Ambulance는 Car라는 공통된 특성이 존재한다.
door,Engine과 같은 공통된 특성을 Car 클래스에서 관리하면 코드의 중복을 피할 수 있고 공통된 특성에 변경이 필요할 때, Car 클래스만 수정하면 되므로 개발자의 실수를 줄일 수 있다는 장점이 있다.

### Q9-1. 클래스를 작성하는데 있어서 상속관계를 맺어줄 것인지, 포함관계를 맺어줄 것인지를 어떻게 결정하는가?
A는 B이다.관계를 가졌다면 상속, A는 B를 가졌다. 관계를 가졌다면 포함관계를 선택하는 것이 일반적이다.
예를들어 Sports Car는 Car이다.가 자연스러우므로 상속관계를 선택하는 것이 일반적이고
Circle은 Point(원점)을 가졌다.가 자연스러우므로 포함관계를 선택하는 것이 일반적이다.

## Q10. C++에서는 다중상속을 허용하는 반면에 Java에서는 다중상속을 허용하지 않는다. 다중상속에 어떤 문제가 있어서 Java는 다중상속을 금지했는가?
C++에서는 다중상속을 허용하지만 몇가지 문제점 때문에 Java에서는 다중상속을 허용하지 않고있다. 다중 상속을 허용하면 클래스간의 관계가 복잡해진다는 단점과, 상속받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없다는 단점이 있다. 이를 해결하기 위해선 조상 클래스의 메서드 이름을 바꾸는 방법 밖에는 없다. 그럼 그 조상 클래스의 메서드를 사용하던 모든 클래스들도 변경해야하므로 간단한 문제가 아니다.
그럼에도 불구하고 다중상속과 같은 기능이 반드시 필요하다면 interface를 이용하여 다중상속을 흉내낼 수 있다.클래스 C가 클래스 A,B를 상속 받아야 하는 상황이라면 클래스 A는 상속, 클래스 B는 포함관계를 맺는다. 클래스 B의 메서드들을 인터페이스로 만든 후, 클래스 C가 이 인터페이스를 구현하도록 한다. 구현부에서는 클래스 B를 통해 메서드를 호출한다면, 다중상속의 장점을 가지되, 다중상속 구현의 어려운 점은 피할 수 있다.

## Q11. 오버라이딩 할 때, 접근 제어자는 조상클래스의 메서드보다 좁은 범위로 변경할 수 없다. 왜 그런가?
리스코프 치환원칙(LSP)라는 것이 있다. 이는 하위 클래스 객체가 상위 클래스 객체를 항상 대체가능해야한다는 것이다.
부모 클래스의 참조변수가 자식 클래스의 참조변수를 참조하고 있을 때, 오버라이딩 된 메서드를 호출한다면 참조변수 타입과 관계없이 실제 인스턴스의 메서드가 호출된다. 부모 클래스의 메서드가 public이였고 자식 클래스의 메서드가 protected라고 가정하자. protected는 같은 패키지에 있는 클래스와 자식클래스에 대해서 접근이 가능한데, 만약 부모와 자식이 같은 패키지에 있지 않다면, 부모 클래스의 참조변수로는 자식 클래스의 메서드를 참조하지 못할것이다. 따라서 리스코프 치환원칙에 위배된다.
솔찍히 이부분 이해가 안갑니다....

[참고 블로그]
1. https://mangkyu.tistory.com/228, 
2. https://inpa.tistory.com/entryOOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-LSP-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99

## Q12. 오버라이딩 할 때, 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다. 왜 그런가?(아직 저도 답을 못내린 질문입니다. 의미없는 질문일 수 있으니, 이거는 나중에 찾아보셔도 될거같아요.)
Parent p=new Parent();
// Parent p=new Child();
try{
    p.methodA(); // 만약 p가 Child인스턴스를 가리키고 있다면 문제가 발생한다. 즉, 자식 객체가 부모 객체를 대체하지 못하는 상황으로 리스코프 치환원칙에 위배된다.
}catch(RuntimeException){

}

class Parent{
    public void methodA() throws RuntimeException{};

}
class Child{
    @Override
    public void methodA() throws Exception{};
}

## Q13. final은 클래스 앞에 붙었을 때, 메서드 앞에 붙었을 때, 멤버변수나 지연변수 앞에 붙었을 때, 각기 다르게 역할을 한다. 각각 어떤 역할을 하는가?
final이 클래스 앞에 붙었을 때는 상속 제한, method앞에 붙었을 때는 오버라이딩 금지, 변수앞에 붙었을 때는 상수로 기능한다.(값 변경 금지)

## Q14. abastact는 클래스앞에 붙었을 때, 메서드 앞에 붙었을 때, 각기 다른 역할을 한다. 각각 어떤 역할을 하는가?
abstract가 클래스 앞에 붙으면 추상클래스임을 의미한다. 추상클래스로 선언되면 클래스 내에 구현되지 않은 추상메서드가 존재한다는 것을 의미한다. 이라한 추상클래스는 인스턴스가 생성될 수 없다는 제약사항이 생긴다. 추상 메서드란 구현되지 않고 메서드의 선언부만 존재하는 메서드를 뜻한다. 추상 클래스를 상속받은 자손 클래스는 이러한 추상 메서드를 반드시 오버라이딩 하도록 강제된다.
이러한 추상 클래스는 다른 클래스를 만드는 공통 설계도로서 역할을 한다.

## Q15. 객체지향의 캡슐화가 무엇이고 어떤 장점이 있는가?

## Q16. Getter나 Setter를 사용하는 이유가 무엇인가?
클래스의 상태를 클래스의 설계자가 의도한 방식으로만 가져가거나 변경할 수 있게 하기 위함이다. 예를들어 주민번호가 990102-XXXXXXX형태로 모자이크 되어 나타나야한다면 getter에서는 모자이크를 시킨후 반환되도록 강제할 수 있다. 하지만 public으로 선언하고 아무대서나 접근 할 수 있게 한다면 설계자가 의도한 대로 접근하지 않을 수 있다.
setter도 마찬가지로 필드값을 설정할 때, 설계자가 요구하는 조건을 만족하는 값만 설정할 수 있도록 강제하는 등. 설계자가 의도한 방식으로만 클래스의 상태에 접근하고 수정할 수 있게 하기위해 사용한다.

## Q17. 생성자에 private을 붙이는 경우가 있는데 왜 붙이는 것인가?
생성자에 private 접근 제어자를 사용하는것은 주로 Singleton Pattern을 구현하기 위해 사용한다. Singleton Pattern은 클래스의 객체를 하나만 만들 수 있도록 제한하는 패턴이다.

프로그램을 구현하다 보면, 클래스의 객체는 하나로 제한되어야 할 때가 있다. 예를들어 스레드 풀, 로그 기록용 객체, 프린터나 그래픽 카드같은 디바이스를 위한 디바이스 드라이버 같은 것들이다. 이러한 객체는 인스턴스를 두 개 이상 만들게 되면 프로그램이 이상하게 돌아간다던가 자원을 불 필요하게 잡아먹는다던가 하는 문제가 생길 수 있다.

### Q17-1. Singleton 패턴을 구현하려면 구체적으로 어떻게 해야할까요?
위 답변은 너무 길어지며 멘토링 대비와는 거리가 있어 직접 작성한 블로그 링크로 첨부한다.

[블로그] 
:https://ayaan-dev.tistory.com/13

## Q18. 다형성(Polymorphism)이 무엇인가?
조상 클래스의 참조타입은 자기 자신뿐만 아니라 자손 클래스의 인스턴스 또한 참조할 수 있고 이를 다형성이라 부른다. 이를 이용하면 메서드의 매개변수나 반환타입을 조상타입으로 설정하여 각각의 객체마다 오버로딩하여 구현하는 것이 아닌 하나의 메서드에서 관리할 수 있다.
또한 다형성을 이용하면 컬렉션에 여러 타입의 객체를 저장하는 것 또한 가능하다.

## Q18-1. 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하는것이 가능한 반면에, 자손 클래스 타입의 참조변수로 조상 클래스의 인스턴스를 참조하는 것은 불가능하다. 이유가 무엇인가?
자손 클래스의 인스턴스를 생성하면자손 클래스의 멤버들만 메모리를 할당받는 것이 아닌 조상 클래스의 멤버들도 메모리를 할당받는다. 참조변수의 타입이 무엇인지에 따라 호출할 수 있는 멤버가 결정되는데,
조상타입의 참조변수로 접근할 수 있는 멤버들은 자손클래스의 객체도 항상 가지고 있는 반면, 자손클래스 타입의 참조변수가 조상 클래스의 객체를 참조하면 존재하지 않는 멤버에 접근할 가능성이 있으므로 이는 금지된다.

## Q19. 자손타입을 조상타입으로 형변환 하는 것을 Up-Casting, 조상타입을 자손타입으로 형변환 하는 것을 Down-Casting이라 한다. Up-casting은 형변환 생략이 가능한 반면, Down-Casting은 형변환 생략이 불가능하다. 이유가 무엇인가?
조상타입의 참조변수로는 본인 클래스의 객체 뿐만 아닌 자손 타입의 객체도 참조 가능하므로 참조하고 있는 객체가 본인인지, 자손인지와 상관없이 문법적으로 올바르다.
반면, 자손타입의 참조변수는 조상타입의 객체를 참조하는 것이 금지되어 있으므로 실제 인스턴스가 자손타입일 때만 허용된다.
따라서 프로그래머가 명시적으로 지정해줄 때만 형변환을 사용할 수 있도록 강제하고 있는 것이다.

## Q20. 인터페이스란 무엇이고 왜 사용하는가?
인터페이스란 클래스의 설계도로 생각하면 된다. abstract class와 다른점은 abstract class는 일부 구현된 메서드가 있을 수 있으나 interface는 모든 메서드가 추상 메서드이다.
인터페이스를 사용하는 이유는 첫째, 연관성이 없는 클래스간에 다형성을 사용할 수 있게 해준다. class A와 class B가 부모-자손 관계가 아니더라도 같은 interface를 구현한다면 그 인터페이스를 통해서 다형성을 사용할 수 있다.
두번째는 클래스간의 결합도를 낮추기 위해 사용된다. 이것이 어떻게 결합도를 낮춰줄 수 있는지 이해가 안된다.^^

## Q20-1. 인터페이스에서 Default 메소드란 무엇인가? Default 메소드는 JDK 1.8부터 추가되었다. 어떤 불편한 점을 해결하기 위해 추가되었는가?
인터페이스에 추상 메서드를 추가한다는 것은, 그 인터페이스를 구현한 모든 클래스에 메서드가 추가되어야 한다는 것을 의미한다. 따라서 인터페이스에 새로운 메서드를 추가하는 것은 쉽지 않다. 따라서 인터페이스도 추상 메서드가 아닌 구현한 메서드를 추가할 수 있어야 한다는 필요성이 생겼고 이것을 Default 메서드라 한다.

### Q20-2. Class의 다중상속은 금지되지만 interface의 다중상속은 허용된다. 이유가 뭔가?

## Q21. 에러와 예외의 차이를 설명하여라.
에러는 프로그램 코드에 의해서 수습될 수 없는 심각한 오류이며
예외는 프로그램 코드에 의해 수습될 수 있는 비교적 미약한 오류이다.
에러는 컴파일 에러, 런타임 에러, 논리적 에러로 나뉜다. 컴파일 에러란 문법적으로 문제가 있어 컴파일 시점에 발생하는 에러이다. 런타임 에러란 실행도중에 발생하는 에러이며, 논리적 에러는 실행은 되지만 의도와는 다르게 동작하는 에러이다. 예외는 RuntimeException과 그외의 Exception으로 나뉜다. RuntimeException은 주로 프로그래머의 실수에 의해서 발생할 수 있는 예외이고 그외의 Exception은 외부의 영향으로 발생할 수 있는 예외로서, 프로그램의 사용자들의 동작에 의해서 발생하는 경우가 많다. RuntimeException은 unchecked Exception이라 불리는데 RuntimeException은 예외 처리가 강제되지 않기 때문이다. 그외의 Exception은 checked Exception이라 불리며 예외처리가 강제된다.
따라서 RuntimeException은 try-catch문을 통해 발생할 수 있는 예외를 컨트롤 하지 않아도 컴파일 에러가 발생하지 않지만, 그외의 Exception은 예외처리를 하지않으면 컴파일 에러가 발생하여 예외처리를 하라 알려준다.

## Q22. 예외를 처리해야하는 이유가 무엇인가?
예외를 처리하지 않으면 프로그램이 비정상 적으로 종료될 수 있다. 서비스되고있는 서버의 프로그램이 비정상 적으로 종료된다면 회사에 아주 큰 손해를 끼칠 수도 있다. 따라서 이러한 예외들을 try-catch문을 통해 컨트롤 하여 비정상적인 종료가 발생하지 않도록 하기위해 예외를 처리해야한다.

### Q22-1. Runtime Exception의 경우 예외처리가 강제되지 않는다. 이유가 무엇인가?
Runtime Exception은 프로그래머의 실수에 의해 발생할 수 있는 예외들로 구성되어있다. 만약에 이런 예외까지 모두 예외처리를 해야한다면 예외가 발생하지 않을것임이 명확한 코드부분에도 너무많은 예외처리 코드가 들어가한다. 따라서 Runtime Exception의 경우는 예외처리를 강제하지 않고있다.

## Q23. JDK 1.7버전부터 try-with-resources문이 추가되었다. 기존 finally를 사용하는 방식에 비해 어떤 장점이 있는가?
주로 I/O작업에 사용되는 클래스들 중에는 사용후에 반드시 닫아줘야 하는 것들이 있다. 그래야 사용했던 자원이 반환되기 때문이다.
옛날에는 주로 finally절 안에 close()메서드를 호출해서 코드의 예외발생 여부와 관계없이 항상 자원을 반환하도록 작성하였다.
이때, close()메서드 또한 checked 예외가 발생할 수 있으므로 finally 구문 안에 또 try-catch문이 들어가야만 했다. 이러한 코드는 너무 복잡해져 가독성을 떨어트린다는 단점이 있다. 이러한 문제점을 해결하기 위해 나온것이 try-with-resources문인데 try뒤의 ()에 객체를 생성하는 문장을 넣으면 이 객체는 close()를 호출 하지 않아도 try블럭을 벗어나는 순간 자동으로 close되며 이러한 close를 위해서 이중으로 try-catch를 작성하지 않아도 된다.

## Q24. Object클래스의 equals()와 hashcode()는 왜 항상 같이 오버라이딩 하라 하는걸까?
equals()는 동등성을 비교하는 메서드를 구현하기 위해 오버라이딩 한다. 반면, hashCode는 원래는 객체의 주소를 통해 만들어지는 해시값을 반환하지만, 동등하면 같은 해시값이 반환되도록 만들기 위해 hashcode()를 오버라이딩한다.
만약, equals와 hashcode중 하나만 구현한다면 HashSet, HashMap과 같은 컬렉션 프레임워크를 사용할 때, 문제가 발생할 수 있다. 위와같은 컬렉션 프레임워크는 Key가 같은지를 확인하기 위해 hashCode와 equals를 모두 확인한다. hashCode는 동등하다면 반드시 같은 값을 반환하지만 같은 값을 가진다고 꼭 동등한건 아니게 hashCode를 오버라이딩 할 수 있다. 비교하는 시간을 최적화 하기위해 hashCode를 먼저 비교하며 hashCode값이 다르면 Key값이 다름을 바로 알 수 있고, hashCode값이 같다면 equals까지 비교해본다. 만약 둘 중 하나만 오버라이딩 하면 Key값이 같음에도 Key값이 다르다는 결과가 나오는 문제를 겪게될 것이다.
## Q25. Object클래스의 clone 메소드를 오버라이딩하기 위해서는 반드시 Cloneable interface를 구현해야한다. 그 이유는 무엇인가?

## Q26. 얕은 복사와 깊은 복사에 대해 설명해보라.
얕은 복사란 원본이 가지고있는 값을 그대로 복사하는 것이라 원본이 참조하고 있는 객체는 객체의 주소값이 복제되어 복사본과 같은 객체를 공유하게 된다.
반면, 깊은 복사란 원본이 참조하고 있는 객체까지 모두 복사하게 되어 원본과 같은 객체를 공유하지 않는다.

### Q26-1. clone()은 둘 중 무엇에 해당하는가?
얕은 복사!

### Q26-2. clone()이 얕은 복사라는 점 때문에 종종 의도치않은 문제가 야기되곤 한다. 어떨때, 문제가 발생하는가?
clone을 통해 복사하면 이는 얕은 복사기 때문에 원본이 가리키고 있는 객체를 복사본과 공유하게 된다.
이때 복사본에서 공유하고 있는 객체를 수정하면, 원본까지 수정되게 되어 의도와는 다른 결과가 나올 수 있다. 따라서 일부러 의도하는게 아니라면 clone()메서드를 사용할 때는, 오버라이딩하여 깊은 복사가 되도록 수정해주는 것이 좋다.

## Q29. String a="a"; String b="b"; String c=a+b;와 같이 String클래스는 "+"를 사용해서 문자열을 결합하는 것은 비효율적인 작업이 수반된다. 이를 설명하여라.

### Q29-1. '+'연산을 통해 문자열 결합이 필요한 경우 String을 대신해 어떤 클래스를 사용하는 것이 좋은가?

### Q29-2. StringBuffer와 StringBuilder는 어떤 차이가 있는가?

### Q29-3. String a="a"; String b="b"; String c="c"; ...
String str=a+b+c+d+e;와 같이 +연산자를 한줄에 결합하면 비교적 문제가 없는가..?( 위와 같은 이야기를 예전에 들어본 적이 있어요. 다만 제가볼 때, 이해가 안가는 부분이라 이것이 진실인지 찾아보려 합니다. 아직 안찾아보셔도 될거같아요)

## Q30. 문자열 리터릴(String Literal)이란 무엇인가?
"abc"와 같이 큰따움표로 둘러싸인 부분을 말한다. 이 코드는 소스코드 상에서 수정을 할 수 없다. String a="가나다", String b="가나다"와 같이 여러 String 객체에 문자열 리터럴을 대입하면, a와 b가 초기화 될 때마다 반복적으로 "가나다"를 가진 메모리공간이 할당되서 참조되는것이 아니라 constant pool에서 문자열 리터럴을 찾아 같은 문자열 리터럴을 참조하게 한다.

### Q30-1. 문자열 리터럴은 JVM의 어디에 저장되는가?
Method Area의 Constant Pool에 저장된다.

## Q32. 오토박싱과 언박싱에 대해 설명하여라
JDK1.5 이전에는 기본형과 참조형간의 연산이 불가능했기 때문에, 래퍼 클래스로 기본형을 객체로 만들어서 연산해야 했다. 그러나 이제는 기본형과 참조형 간의 연산이 가능하다. 기본형과 참조형간의 연산이 이루어질 때는, 컴파일러가 자동으로 기본형을 참조형으로 변환시켜 주거나, 반대로 참조형을 기본형으로 변환시키는 코드를 삽입한다. 전자를 오토박싱, 후자를 언박싱이라 부른다.

## QFM(멘토님게 질문하고 싶은 것.)
1. abstact class와 interface의 차이는 일부 메소드 구현을 허용하냐 정도 밖에 없는거 같다. 단순히 일부 메소드는 구현하길 원하는지에 따라 abstract class로 구현할지 interface로 구현할지를 결정하면 되는건가요? 하나는 class이고 하나는 interface인데 두가지의 용도가 다를거 같다고 생각되는데 딱히 그런건 없나요?
2. static 초기화 블럭은 사용을 지양하라고 말씀하셨습니다. instance 초기화 블럭은 어떤가요?

## 은비님이랑 하고싶은 이야기
1. interface가 어떻게 객체간의 의존성을 줄일 수 있다는 건지 이해가 잘 안됩니다....
