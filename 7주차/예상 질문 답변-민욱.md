# 💡 (8주차) 자바 예상 질문 정리

# 📜 JSP 2.3 웹 프로그래밍

## 1. PreparedStatement객체를 사용하는 이유를 설명하라.
- 간결한 코드 : Statement객체를 사용하면 문자열과 +연산자를 통해 쿼리를 표현하므로 가독성이 떨어지는 반면 preparedStatement는 이미 만들어진 쿼리에 parameter를 채워넣는 포맷형태로 가독성이 훨씬 뛰어나다.
- 보안       : SQL Injection이 자동으로 방어된다.
- 캐싱을 통한 성능향상: gpt4가 뵙고싶네요.
 
## 2. Servlet이 호출될 때 처리 과정을 설명하라.
1. 최초 요청이 들어온다.
2. Servlet객체가 생성된다.
3. init()메서드를 통해 Servlet객체가 초기화된다.
4. 요청을 처리하기 위한 적절한 메서드가 호출된다.
5. 응답 결과를 클라이언트에게 반환한다.

만약 최초 요청이 아니라 Servlet객체가 이미 생성되어 있다면 1,4,5번만 진행된다

### Servlet을 어플리케이션이 로딩되는 시점에 초기화 되도록 설정할 수 있고, 요청이 들어왔을 때 초기화 되도록 설정할 수 있다. 어떤 장단점이 있을까?
Servlet은 web.xml의 설정에 따라 어플리케이션이 로딩되는 시점에 바로 초기화 되도록 만들 수 있다.
장점: 최초 사용자는 Servlet초기화 과정 때문에 응답 속도가 느려지는 단점이 있다.
단점: 어플리케이션이 로딩되는 시점에 초기화 되는 객체가 늘어나면 어플리케이션 한번 실행시키는데 엄청 많은 시간이 걸릴 수 있다.

대안: Lazy Initialization상태를 유지하되 사용자에게 공개하기전 warm up작업을 거치면 어플리케이션 실행에 소요되는 시간을 줄일 수 있으며 최초 사용자가 응답을 받는데 오래걸린다는 문제도 해결된다.

?: Lazy Initialization + warm up 작업은 단점이 없는가?

## 3. 모델1구조와 모델2구조를 비교하라.
![image](https://github.com/MentoringOrganization/Java/assets/46997074/a3a8d7fa-d054-4a48-a6d6-2c7cc19ac530)
![image](https://github.com/MentoringOrganization/Java/assets/46997074/94b8b294-68fe-4c68-b045-d0cdca0066c8)

- 모델1 구조: 
모델1 구조는 클라이언트의 요청을 JSP가 직접 처리한다. 웹 브라우저의 요청을 받은 JSP는 자바빈이나 서비스 클래스를 사용해서 웹 브라우저가 요청한 작업을 처리하고 그 결과를 클라이언트에게 전송한다. JSP페이지에서 웹 브라우저의 요청을 직접 처리한다는 의미는 JSP페이지에 비지니스 로직을 처리하는 코드가 썪인다는것을 의미한다.

- 모델2 구조:
모델 2 구조는 모델1구조와 달리 서블릿이 웹브라우저의 요청을 받는다. 서블릿은 해당 요청을 처리할 수 있는 클래스를 호출하여 비즈니스 로직을 거친다.
그후 JSP페이지로 포워딩하면서 해당 결과값을 함께 넘겨주고 JSP페이지는 결과값을 이용해 페이지를 구성하고 클라이언트에게 응답한다.

### MVC패턴이 무엇인지 설명하라
MVC패턴의 M,V,C는 각각 Model,View,Controller를 지칭한다.

Model: 비지니스 영역의 로직을 처리한다.
View:  비지니스 영역에 대한 프리젠테이션 뷰를 담당한다.
Controller: 사용자의 입력 처리와 흐름 제어를 담당한다.

MVC패턴이란 3가지 컴포넌트로 분리해서 각 컴포넌트는 하나의 역할만 담당하도록 구성하는 것이다. 이를 통해 3가지 역할이 하나의 클래스나 파일에서 썪여서 나타나는 것을 피하고 코드의 가독성과 버그 추적에 이점을 가져가는 패턴이다.

### 위 구조중 무엇이 MVC패턴을 구현하는데 적합한지 설명하라.
모델2 구조가 적합하다. 
1. 웹브라우저의 요청을 받는 Servlet을 Controller로 볼 수 있다.
2. Servlet이 호출하는 비지니스 로직을 담당하는 클래스를 Model로 볼 수 있다.
3. JSP페이지를 View로 볼 수 있다.
따라서 모델2 구조가 MVC패턴에 적절하다고 여겨진다.

모델1 구조의 경우 JSP페이지가 웹 브라우저의 요청을 받으며, JSP에서 여러 클래스를 요청하여 비즈니스 로직을 담당하고 실제 보여지는 View또한 JSP페이지에 들어가므로 여러 역할과 책임을 JSP혼자서 지는 상황이다. 따라서 모델1은 MVC패턴을 구현하기에 적합하지 않다.

## 4. Command Pattern에 대해 설명하고 어떤 이점이 있는지 논하라.
사용자의 요청이 무엇인지를 판단하기 위해 파라미터나 URL을 사용했다면, Servlet에서 해당 요청에 맞게 if 분기문으로 처리해주는 것이 Command Pattern을 사용하지 않았을 때 일반적인 방법이다. 하지만 해당 부분은 너무 많은 분기문이 생겨 코드 가독성이 떨어진다는 단점이 있다. 각 명령어에 해당하는 로직 처리코드를 하나의 클래스로 작성하는 것을 Command Pattern이라 부른다.
각각의 처리 로직을 담당하는 클래스는 CommandHandler Interface를 구현해야한다. 해당 로직은 process()라는 메서드를 구현하여 수행된다.
따라서 Servlet에서는 if분기문 안에서 구현채만 다르게 클래스를 생성하고 최종적으로 process를 호출하는 식으로 코드를 간단히 정리할 수 있다.
이를 Command Pattern이라 부른다.

## 5. Filter가 하는 역할을 설명하라.
Filter란 클라이언트의 요청과 최종 자원(JSP, Servlet)사이에 위치한 객체로 요청이나 응답을 중간에서 변경하거나 조작하는 역할을 한다. Filter가 사용되는 대표적인 예시로는 Logging이나 Login 여부 확인 Filter가 대표적인 예시라 할 수 있다.

### Filter를 구현하는데 Filter 인터페이스, ServletRequestWrapper 클래스, ServletResponseWrapper 클래스가 필수적으로 사용된다. 이것들의 역할을 설명하라.
- Filter Interface: 실제 필터역할을 하는 객체는 해당 interface를 구현한 클래스의 객체여야한다. 해당 interface에는 init, doFilter, destroy 메서드가 선언되어 있다. init은 Filter객체를 초기화 하는 메서드, doFilter는 요청/응답을 조작하는 실제 로직, destory는 필터를 웹 컨테이너에서 삭제할 때 사용되는 메서드로 주로 자원반납을 담당하는 메서드이다.
- ServletRequestWrapper : 요청 정보를 변경하여 최종자원/다음 필터로 요청을 전달한다.
- ServletResponseWrapper: 응답 정보를 변경하여 클라이언트/다음 필터로 응답을 전달한다.

## 6. ServletContextListener에 대해 설명하라.
Servlet 규약에서는 다양한 Event를 확인하고 있는 Listener가 있다. 그중 ServletContextListener는 어플리케이션이 시작되거나 종료되는 것을 event로 하여 실행되는 인터페이스다. ServletContextListener에는 contextInitialized, contextDestroyed 두가지 메서드가 선언되어있다.
해당 인터페이스를 구현하고 메서드들을 오버라이딩 하면 사용할 수 있다.

### ServletContextListener를 사용하는 이유를 설명하라.
web.xml에 <load-on-startup>태그를 이용해서 어플리케이션이 로딩되는 시점에 해당 서블릿도 함께 로딩되도록 설정할 수 있다. 그럼에도 불구하고 ServletContextListener를 사용하는 이유가 무엇일까? 
어플리케이션이 로딩될 때 초기화 되어야하는 객체들을 ServletContextListener를 확인해보면 자바코드로 한번에 확인할 수 있다는 점이 장점인 듯 하다.
이부분은 멘토링때 논의해보면 좋을거 같다.

# 📚 스프링 입문을 위한 자바 객체 지향의 원리와 이해

## 1. 기계어에서 어셈블리어로의 전환 개발자에게 어떤 이점을 주었는가?
기계어는 0과 1의 배열이다. 0과 1로 이루어진 기계어를 인간이 이해하는 것은 매우 힘들다. 어셈블리어는 코드의 가독성 측면에서 개발자에게 혁명이였다. 0과 1의 조합으로 구성되어있던 코드를 ADD, SUB, LD(Load), SD(stored)와 같은 일상어형식으로 바꾸어 줬다.

### Assembler가 하는 일을 설명하라.
컴퓨터는 0과 1밖에 이해하지 못한다. Assembler는 어셈블리어로 된 코드를 기계어로 변환해주는 역할을 한다. Assembler의 등장으로 개발자는 어셈블리어로 코드를 작성하면 Assembler가 기계어로 번역해주는 일을 해주었다.

## 2. 어셈블리어에서 C언어의 등장은 개발자에게 어떤 이점을 주었는가?
어셈블리어가 탄생하여 0과1로 구성된 코드에서 개발자는 벗어날 수 있었지만 여전히 기계마다 제공해주는 instruction set이 달랐으므로 개발자는 기계별로 하나의 코드를 따로따로 작성해야만 했다. 하지만 C언어의 등장으로 개발자는 이러한 노동에서 해방되었다. 

### One Source Multi Object Use Anywhere에 대해 설명하라.
C언어는 코드를 짜서 컴파일하면 Compiler가 C언어를 어셈블리어로 변환해 주었다. 하나의 소스코드로 여러 목적파일을 만들수 있었고 각 목적파일은 각각의 CPU에 맞는 기계어로 변환될 수 있었다. 이를 하나의 소스로 여러 목적파일이 만들어진다고 하여 One Source Multi Object Use AnyWhere라 불렀다. 하지만 C언어에는 한계가 있었는데 각각의 운영체제 별로 조금씩 차이가 있어서 Window에서 작성한 소스 코드를 Linux에서 컴파일 하려 하면 컴파일에러가 발생하곤 했다. 

## 3. 구조적 프로그래밍이란 무엇인가?

### 절차적 프로그래밍과 비교하라.

## 4. POJO가 무엇인지 설명하라.

## 5. JDK, JRE, JVM의 역할을 설명하라.
- JDK: JDK란 자바 개발 도구로써 javac, javaDoc, 각종 라이브러리들이 포함된다. 
- JRE: Java 실행 환경으로 현실 세계의 운영체제를 모방한다. JVM이라는 자원을 사용하여 실제 JAVA를 실행시키는 환경이다.
- JVM: JVM은 가상의 컴퓨터를 모방한다. Stack, Heap, PC와 같은 자바를 실행하는데 필요한 resource를 제공해준다.

### JVM의 중요한 특성인 Write Once Run Anywhere을 설명하라.
Write Once Run AnyWhere란 한번 작성하면 어디서든 실행될 수 있다는 것이다. 이전 C언어는 C 코드를 작성하고 Compiler가 컴파일해줌으로써 기계에 종속적인 코드에서는 벗어났으나 운영체제에는 종속된다는 문제를 가졌다. Java는 javac에의해 컴파일되면 Java ByteCode가 된다. Java ByteCode는 JIT Compiler에 의해 각 운영체제와 cpu에 맞는 기계어로 번역되고 JVM위에서 실행된다.

## 6. java 어플리케이션이 실행되는 과정을 설명하라.
1. JRE는 먼저 프로그램 안에 main()메서드가 있는지 확인한다.
2. main() 메서드의 존재가 확인되면 JRE는 프로그램 실행을 위한 사전 준비에 착수한다.
3. JRE는 JVM에게 목적파일을 전달하고 JVM은 그 목적파일을 실행한다.
4. java.lang 패키지는 모든 프로그램이 포함하게 되는 패키지므로 JVM은 해당 패키지르 먼저 static영역에 로딩한다.
5. JVM은 개발자가 작성한 모든 클래스와 import 패키지 역시 스태틱 영역에 가져다 놓는다.
6. main()메서드가 스택 프레임으로 올라간다.
7. 그후 어플리케이션이 정상적으로 실행되다가 main()메서드가 스택에서 사라지면 JRE는 JVM을 메모리에서 내리고 본인도 종료된다.

Class는 실제 사용되기 직전에 로딩되지 않나..?

## 8. 클래스와 객체에 대해 설명하라.
클래스는 분류(개념), 객체는 실체에 대응된다. 사람은 개념이며 정민욱은 실체이다. 팽귄은 개념이며 뽀로로는 실체이다. 이와 같이 어떠한 분류/개념에 해당하는 것은 클래스에 해당하고 그에 속하는 실체를 우리는 객체라고 부른다.