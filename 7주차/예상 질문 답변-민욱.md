# 💡 (8주차) 자바 예상 질문 정리

# 📜 JSP 2.3 웹 프로그래밍

## 1. PreparedStatement객체를 사용하는 이유를 설명하라.
- 간결한 코드 : Statement객체를 사용하면 문자열과 +연산자를 통해 쿼리를 표현하므로 가독성이 떨어지는 반면 preparedStatement는 이미 만들어진 쿼리에 parameter를 채워넣는 포맷형태로 가독성이 훨씬 뛰어나다.
- 보안       : SQL Injection이 자동으로 방어된다.
- 캐싱을 통한 성능향상: gpt4가 뵙고싶네요.
 
## 2. Servlet이 호출될 때 처리 과정을 설명하라.
1. 최초 요청이 들어온다.
2. Servlet객체가 생성된다.
3. init()메서드를 통해 Servlet객체가 초기화된다.
4. 요청을 처리하기 위한 적절한 메서드가 호출된다.
5. 응답 결과를 클라이언트에게 반환한다.

만약 최초 요청이 아니라 Servlet객체가 이미 생성되어 있다면 1,4,5번만 진행된다

### Servlet을 어플리케이션이 로딩되는 시점에 초기화 되도록 설정할 수 있고, 요청이 들어왔을 때 초기화 되도록 설정할 수 있다. 어떤 장단점이 있을까?
Servlet은 web.xml의 설정에 따라 어플리케이션이 로딩되는 시점에 바로 초기화 되도록 만들 수 있다.
장점: 최초 사용자는 Servlet초기화 과정 때문에 응답 속도가 느려지는 단점이 있다.
단점: 어플리케이션이 로딩되는 시점에 초기화 되는 객체가 늘어나면 어플리케이션 한번 실행시키는데 엄청 많은 시간이 걸릴 수 있다.

대안: Lazy Initialization상태를 유지하되 사용자에게 공개하기전 warm up작업을 거치면 어플리케이션 실행에 소요되는 시간을 줄일 수 있으며 최초 사용자가 응답을 받는데 오래걸린다는 문제도 해결된다.

?: Lazy Initialization + warm up 작업은 단점이 없는가?

## 3. 모델1구조와 모델2구조를 비교하라.
![image](https://github.com/MentoringOrganization/Java/assets/46997074/a3a8d7fa-d054-4a48-a6d6-2c7cc19ac530)
![image](https://github.com/MentoringOrganization/Java/assets/46997074/94b8b294-68fe-4c68-b045-d0cdca0066c8)

### MVC패턴이 무엇인지 설명하라

### 위 구조중 무엇이 MVC패턴을 구현하는데 적합한지 설명하라.

## 4. Command Pattern에 대해 설명하고 어떤 이점이 있는지 논하라.

## 5. Filter가 하는 역할을 설명하라.

### Filter를 구현하는데 Filter 인터페이스, ServletRequestWrapper 클래스, ServletResponseWrapper 클래스가 필수적으로 사용된다. 이것들의 역할을 설명하라.

## 6. ServletContextListener에 대해 설명하라.

### ServletContextListener를 사용하는 이유를 설명하라.

# 📚 스프링 입문을 위한 자바 객체 지향의 원리와 이해

## 1. 기계어에서 어셈블리어로의 전환 개발자에게 어떤 이점을 주었는가?
기계어는 0과 1의 배열이다. 0과 1로 이루어진 기계어를 인간이 이해하는 것은 매우 힘들다. 어셈블리어는 코드의 가독성 측면에서 개발자에게 혁명이였다. 0과 1의 조합으로 구성되어있던 코드를 ADD, SUB, LD(Load), SD(stored)와 같은 일상어형식으로 바꾸어 줬다.

### Assembler가 하는 일을 설명하라.
컴퓨터는 0과 1밖에 이해하지 못한다. Assembler는 어셈블리어로 된 코드를 기계어로 변환해주는 역할을 한다. Assembler의 등장으로 개발자는 어셈블리어로 코드를 작성하면 Assembler가 기계어로 번역해주는 일을 해주었다.

## 2. 어셈블리어에서 C언어의 등장은 개발자에게 어떤 이점을 주었는가?
어셈블리어가 탄생하여 0과1로 구성된 코드에서 개발자는 벗어날 수 있었지만 여전히 기계마다 제공해주는 instruction set이 달랐으므로 개발자는 기계별로 하나의 코드를 따로따로 작성해야만 했다. 하지만 C언어의 등장으로 개발자는 이러한 노동에서 해방되었다. 

### One Source Multi Object Use Anywhere에 대해 설명하라.
C언어는 코드를 짜서 컴파일하면 Compiler가 C언어를 어셈블리어로 변환해 주었다. 하나의 소스코드로 여러 목적파일을 만들수 있었고 각 목적파일은 각각의 CPU에 맞는 기계어로 변환될 수 있었다. 이를 하나의 소스로 여러 목적파일이 만들어진다고 하여 One Source Multi Object Use AnyWhere라 불렀다. 하지만 C언어에는 한계가 있었는데 각각의 운영체제 별로 조금씩 차이가 있어서 Window에서 작성한 소스 코드를 Linux에서 컴파일 하려 하면 컴파일에러가 발생하곤 했다. 

## 3. 구조적 프로그래밍이란 무엇인가?

### 절차적 프로그래밍과 비교하라.

## 4. POJO가 무엇인지 말하라.

## 5. JDK, JRE, JVM의 역할을 설명하라.
- JDK: JDK란 자바 개발 도구로써 javac, javaDoc, 각종 라이브러리들이 포함된다. 
- JRE: Java 실행 환경으로 현실 세계의 운영체제를 모방한다. JVM이라는 자원을 사용하여 실제 JAVA를 실행시키는 환경이다.
- JVM: JVM은 가상의 컴퓨터를 모방한다. Stack, Heap, PC와 같은 자바를 실행하는데 필요한 resource를 제공해준다.

### JVM의 중요한 특성인 Write Once Run Anywhere을 설명하라.
Write Once Run AnyWhere란 한번 작성하면 어디서든 실행될 수 있다는 것이다. 이전 C언어는 C 코드를 작성하고 Compiler가 컴파일해줌으로써 기계에 종속적인 코드에서는 벗어났으나 운영체제에는 종속된다는 문제를 가졌다. Java는 javac에의해 컴파일되면 Java ByteCode가 된다. Java ByteCode는 JIT Compiler에 의해 각 운영체제와 cpu에 맞는 기계어로 번역되고 JVM위에서 실행된다.

## 6. java 어플리케이션이 실행되는 과정을 설명하라.
1. JRE는 먼저 프로그램 안에 main()메서드가 있는지 확인한다.
2. main() 메서드의 존재가 확인되면 JRE는 프로그램 실행을 위한 사전 준비에 착수한다.
3. JRE는 JVM에게 목적파일을 전달하고 JVM은 그 목적파일을 실행한다.
4. java.lang 패키지는 모든 프로그램이 포함하게 되는 패키지므로 JVM은 해당 패키지르 먼저 static영역에 로딩한다.
5. JVM은 개발자가 작성한 모든 클래스와 import 패키지 역시 스태틱 영역에 가져다 놓는다.
6. main()메서드가 스택 프레임으로 올라간다.
7. 그후 어플리케이션이 정상적으로 실행되다가 main()메서드가 스택에서 사라지면 JRE는 JVM을 메모리에서 내리고 본인도 종료된다.

Class는 실제 사용되기 직전에 로딩되지 않나..?

## 8. 클래스와 객체에 대해 설명하라.
