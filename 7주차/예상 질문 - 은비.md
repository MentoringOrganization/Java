# 💡 (8주차) 자바 예상 질문 정리

## [JSP 2.3 프로그래밍]
- https://velog.io/@jsj3282/%ED%95%84%ED%84%B01-%ED%95%84%ED%84%B0%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

## 1. Servlet(서블릿)은 무엇인가? JSP와 연관지어 설명해보자.

![image](https://github.com/MentoringOrganization/Java/assets/103405457/9c717567-2e3a-4614-90be-7b5802353eb8)

### Servlet

Servlet(서블릿)은 JSP 표준이 나오기 전에 만들어진 표준으로 자바로 웹 어플리케이션을 개발할 수 있도록 하기 위해 만들어졌다.

즉, 서버에서 실행되는 자바 프로그램으로 클라이언트의 요청을 처리하고 결과를 반환한다. 또한 웹 서버가 시작될 때 로드되고 초기화되며, 그 후 클라이언트의 요청에 따라 동작한다. 

일반적으로 HTML, XML, JSON 등의 형식으로 응답을 생성한다.

### JSP

![image](https://github.com/MentoringOrganization/Java/assets/103405457/e23ca31c-401a-4da3-a9dc-8d521dabec3d)

JSP(Java Server Pages)는 HTML 내에 자바 코드를 포함하는 기술로서 HTML, XML 등의 기타 문서 유형을 생성한다.

최초 요청 시 서블릿으로 변환되고 컴파일된 후, 이후의 요청에 대해 동작한다. 변환된 서블릿을 웹 컨테이너에서 관리된다.

<details>
  <summary> 제외된 질문 1 </summary>
  - 서블릿은 HTTP 방식에 따라 알맞은 메서드를 재정의해서 구현해야 한다. 이때, 어느 메서드를 사용해서 재정의하는가? 또, 해당 메서드의 파라미터는 어떤 것을 의미하는가?
</details>

<details>
  <summary> 제외된 질문 2 </summary>
  - 서블릿을 등록하려면 두 가지를 설정해야 한다. 즉, 서블릿으로 사용할 클래스를 등록한 후 서블릿은 어떤 URL을 처리할 지 매핑 정보를 등록해야한다. 이때, 매핑하는 방법은 어떤 것들이 있는가?
</details>

## 2. JSP 웹 어플리케이션의 구조에서 모델 1 구조와 모델 2 구조를 설명해보자.

### 이때, 두 구조의 차이는 무엇일까?

### 모델 1

![image](https://github.com/MentoringOrganization/Java/assets/103405457/0891f259-eff1-4ca9-ba3a-aea84da62492)

JSP에서 **모든 로직**과 **출력**을 처리하는 구조로서, 웹 브라우저의 요청을 JSP가 직접 처리한다.

웹 브라우저의 요청을 받은 JSP는 자바빈이나 서비스 클래스를 사용해서 웹 브라우저가 요청한 작업을 처리하고, 그 결과를 클라이언트에 출력한다. 즉, JSP 페이지에 비즈니스 로직을 처리하기 위한 코드와 웹 브라우저에 결과를 출력하는 코드가 섞인다.

> ex. 하나의 JSP 페이지에서 서비스 클래스를 통해서 글쓰기/읽기 등의 작업을 수행(비즈니스 로직)하고 그 결과를 출력(웹 브라우저에 결과 출력)

### 모델 2

![image](https://github.com/MentoringOrganization/Java/assets/103405457/2e880a40-af30-48e5-bf53-b0e296b58275)

서블릿과 JSP가 함께 비즈니스 로직과 출력을 처리하는 구조로서, 웹 브라우저의 요청을 하나의 서블릿이 받고 결과를 JSP 페이지로 포워딩한다. 이후, JSP 페이지는 결과 화면을 클라이언트에 전송한다.

모델 2는 웹 브라우저의 모든 요청을 하나의 서블릿이 받기 때문에 서블릿은 웹 브라우저의 모든 요청을 구분할 방법이 필요하다. 이때, 나온 것이 MVC 패턴(Model-View-Controller) 패턴이다.

## 3. MVC 패턴이 무엇이며 동작 과정을 설명해보자.

![image](https://github.com/MentoringOrganization/Java/assets/103405457/bf234fec-9e3e-4556-8015-9382beb44e8f)

- Model(모델) : 비즈니스 영역의 로직을 처리
- View(뷰) : 비즈니스 영역에 대한 프레젠테이션 뷰, 즉 사용자가 보게 될 결과 화면을 담당
- Controller(컨트롤러) : 사용자의 입력 처리와 흐름 제어를 담당

> ex. 모델 : 은행 계좌 관리 시스템에서 계좌 잔액 계산 / 이체 작업 / 입출금 처리 등을 담당
> > 컨트롤러 : 사용자가 웹 페이지에서 이체 버튼을 누르면, 컨트롤러는 이 정보를 받아 해당 계좌의 모델을 업데이트한 후 사용자에게 보여줄 뷰를 갱신
> > > 뷰 : 최종적으로 사용자에게 결과 화면을 출력

### 동작 과정

1. 사용자는 원하는 기능을 처리하기 위한 모든 요청을 컨트롤러에 보낸다.
- 컨트롤러는 비즈니스 로직을 포함하지는 않지만 전체 웹 어플리케이션에 일괄적으로 적용되는 기능을 처리한다.
2. 컨트롤러는 모델을 이용해서 알맞은 비즈니스 로직을 수행한 후 사용자에게 보여줄 뷰를 선택한다.
- 모델은 비즈니스와 관련된 로직을 처리할 뿐 사용자에게 보일 화면이나 흐름 제어에 대해서는 처리하지 않는다.
3. 선택된 뷰는 사용자에게 알맞은 결과 화면을 보여준다.
- 뷰는 사용자에게 알맞은 화면을 보여주는 역할만 수행할 뿐, 비즈니스 로직이나 흐름 제어 등을 처리하지 않는다.

이러한 MVC 패턴은 **비즈니스 로직을 처리하는 모델과 결과 화면을 보여주는 뷰를 분리** 및 **어플리케이션의 흐름 제어나 사용자의 처리 요청은 컨트롤러에 집중**됨으로써 모델의 내부 로직과 뷰는 독립적으로 구성된다. 따라서 MVC 패턴을 사용함으로써 유지보수 작업이 쉬워지고 어플리케이션을 쉽게 확장할 수 있게 된다.

## 4. MVC 패턴과 모델 2 구조를 매핑해보자.

### 컨트롤러 - ?

<details>
  <summary> 정답 </summary>
  서블릿
</details>

### 모델 - ?

<details>
  <summary> 정답 </summary>
  로직 처리 클래스, 자바빈
</details>

### 뷰 - ?

<details>
  <summary> 정답 </summary>
  JSP
</details>

### 사용자 - ?

<details>
  <summary> 정답 </summary>
  웹 브라우저 또는 휴대폰과 같은 다양한 기기
</details>

## 5. MVC 내에서 서블릿의 내부 동작 방식을 말해보자.

![image](https://github.com/MentoringOrganization/Java/assets/103405457/2c4acdd2-0da2-41bd-967d-b3037011c6df)

1. 서블릿이 HTTP 요청을 받는다.
2. 웹 브라우저가 어떤 기능을 요청했는지 분석한다.
3. 모델을 사용하여 요청한 기능을 수행한다.
4. 모델로부터 전달받은 결과물을 가공한 후, request / session의 setAtrribute() 메서드를 사용하여 속성에 저장한다.
5. 웹 브라우저에 결과를 전송할 JSP를 선택한 후, 해당 JSP로 결과물을 포워딩한다. 경우에 따라 리다이렉트(포워딩과 유사하지만, URL이 변경됨)을 수행한다.

### MVC 내에서 서블릿과 모델 간의 통신 과정을 말해보자.

![image](https://github.com/MentoringOrganization/Java/assets/103405457/b3dbea13-a7f5-45d9-9778-02afaf316475)

1. 서블릿은 모델을 사용하여 비즈니스 로직을 수행하기 위해 알맞은 모델을 호출한다.
2. 모델은 컨트롤러(서블릿)로부터 요청을 받는다.
3. 서비스 클래스나 DAO 클래스를 이용해서 비즈니스 로직을 수행한다.
4. 수행 결과를 자바빈에 저장하여 리턴한다. 

## 6. JSP/서블릿 관련해서 필터는 무엇이며 왜 사용할까?

![image](https://github.com/MentoringOrganization/Java/assets/103405457/abf9dc37-4f82-483a-b336-da1d8f00cb31)

필터는 HTTP 요청과 응답을 변경할 수 있는 재사용 가능한 클래스이다.

객체의 형태로 존재하며 클라이언트에서 오는 요청(request)과 최종 자원(JSP, 서블릿, 기타 자원) 사이에 위치하여 클라이언트의 요청 **정보를 알맞게 변경**한다. 또한 최종 자원과 클라이언트로 가는 응답(response) 사이에 위치하여 최종 자원의 요청 결과를 변경할 수도 있다.

필터는 여러 개가 존재할 수 있으며, 여러 개의 필터가 모일 경우 필터 체인(chain)이라고 일컫는다.

이럴 경우, 첫 번째 필터는 클라이언트의 요청 정보가 되지만 두 번째 필터부터는 첫 번째 / 두 번째 / .. / n 번째 필터를 통해서 변경된 요청 정보가 된다. 응답 정보의 경우 반대의 순서대로 이뤄진다.

## 7. 웹 어플리케이션이 시작되고 종료될 때 특정한 기능을 실행하려면 어떤 처리 방법이 있을까?

우선 웹 컨테이너는 웹 어플리케이션이 시작되거나 종료되는 시점에 특정 클래스의 메서드를 실행할 수 있는 기능을 제공한다. 이 기능을 사용하면 웹 어플리케이션을 실행할 때 필요한 초기화 작업이나 웹 어플리케이션이 종료된 후 사용된 자원을 반환하는 등의 작업을 수행할 수 있다.

웹 어플리케이션이 시작되고 종료될 때 특정한 기능을 실행하려면 **ServletContextListener**를 이용하여 이벤트 처리를 할 수 있다.

---

## [자바 객체 지향의 원리와 이해]

## 8. 기계어 vs 어셈블리어 vs C언어

<details>
  <summary> 정답 </summary>
  |제목|내용|설명|
  |------|---|---|
  |테스트1|테스트2|테스트3|
  |테스트1|테스트2|테스트3|
  |테스트1|테스트2|테스트3|
  
  왜 안 될까?
  
  |표|기계어|어셈블리어|C언어|
  |개발자의코딩|0과1의나열|일상단어사용|수학적기호사용|
  |소스파일|기종마다하나씩|기종마다하나씩|기종이몇개든단하나|
  |목적파일(기계어)|소스그자체|어셈블러로소스를번역해생성|컴파일러로소스를번역해생성|
  |기계어비교|없음|기계어와1:1대응하는니모닉(기호)|기계어와m:n대응하는수학적기호|
</details> 

### C++ vs C# vs 자바

- C++ : (객체 없는 프로그래밍도 가능하긴 하지만) 객체 지향 언어
- C# 및 자바 : 객체 지향 언어 + 가상 머신(Virtual Machine)

## 9. Spring을 [개념]과 [제품]으로 설명해보자.

### [개념]

OOP(Object Oriented Programming) Framework

### [제품]

Spring

### Spring Framework는 왜 어렵다고 하는걸까?

첫 번째는 스프링의 개념을 명확히 알지 못하기 때문이고, 두 번째는 제품이 너무 방대하기 때문이다.

### Spring의 강점은?

첫 번째는 규모, 즉 제품의 방대함에도 불구하고 끈 이론과 같은 일관성 있는 방식으로 쌓아올렸는 점이고, 두 번째는 EA(Emterprise Application)을 구현하는 데 필요한 거의 모든 서비스를 지원한다는 점이다.

### 스프링 삼각형이란?

![image](https://github.com/MentoringOrganization/Java/assets/103405457/4b98b8d5-6e17-40db-bb18-1b14e74d4a38)

이때, POJO(Plain Old Java Object, 💥)란 "오래된 방식의 간단한 자바 오프젝트"라는 말로써 특정 기술에 종속되어 동작하는 것이 아닌 순수한 자바 객체를 말하는 것이다.
> ex. ORM(Object Relationship Mapping) 기술을 사용하고 싶었다면 ORM을 지원하는 ORM 프레임워크를 사용해야 한다.

## 10. 현실 세계의 개념들과 비교하여 가상 세계의 자바 관련 개념들을 설명해보자.

### 소프트웨어 개발 도구 - ?

<details>
  <summary> 정답 </summary>
  JDK(자바 개발 도구)
</details>

### 운영체제 - ?

<details>
  <summary> 정답 </summary>
  JRE
</details>

### 하드웨어 - ?

<details>
  <summary> 정답 </summary>
  JVM
</details>

## 11. JVM에서 JRE와 JVM이 하는 일을 main() 메서드 스택 프레임과 관련하여 설명해보자.

### JRE

프로그램 안에 main() 메서드가 있는지 확인한다. 이후 main() 메서드가 존재한다면 JRE는 프로그램 실행을 위한 사전 준비, 즉 JVM을 로드한다.

### JVM

목적 파일을 받아 실행한 후 전처리를 진행한다. 즉, java.lang 패키지를 T 메모리의 static 영역에 가져다 놓는다.

다음으로 개발자가 작성한 모든 클래스와 임포트 패키지를 static 영역에 가져다 놓는다.

이후 main() 메서드 stack frame 배치, 변수 공간 배치 등등의 일을 처리한다.

## 12. T라는 메모리는 세 개의 영역이 있는데, 변수는 스태틱 영역/스택 영역/힙 영역 중 어디에 있는가?

### 왜 그렇게 생각했는가?

<details>
  <summary> 정답 </summary>
  세 군데 모두이다.
  즉, 클래스 멤버 변수/지역 변수/객체 멤버 변수로서 존재한다.
</details>

## 13. "외부 스택 프레임에서 내부 스택 프레임의 변수에 접근하는 것은 불가능하나 그 역은 가능하다." 왜 그럴까?

여기서 내부 스택 프레임의 변수란 지역 변수를 일컫는다. 따라서 지역 변수는 지역 내부(해당 내부 스택 프레임)에서만 사용이 가능하고, 외부에서는 사용할 수 없기 때문에 그 역만 가능한 것이다.
> ex. if 블록 스택 프레임 외부에 존재하는 변수 k는 메모리 상에 변수 k가 존재하기 때문에 if 블록 스택 프레임에 접근할 수 있다.

### "메서드 스택 프레임에서 다른 메서드 스택 프레임의 내부 변수는 접근이 불가능하다." 왜 그럴까?

위 내용을 **메서드를 블랙박스화**한다고 한다. 입력값들과 반환값에 의해서만 메서드 사이에서 값이 전달될 뿐 서로 내부의 지역 변수는 볼 수 없기 때문이다.

## 14. 왜 요청 당 스레드가 요청 당 프로세스보다 더 효율적일까?

멀티 프로세스는 각 프로세스마다 각자의 T 메모리가 있고 고유의 공간이므로 서로 참조할 수 없다. 반면 멀티 스레드는 하나의 T 메모리만 사용하는데 스택 영역만 분할해서 사용하는 구조이다.

멀티 프로세스는 하나의 프로세스가 다른 프로세스의 T 메모리 영역을 절대 침범할 수 없는 구조이기에 메모리 사용량이 큰 반면 멀티 스레드는 스태틱 영역과 힙 영역은 공유해서 사용하는 구조이므로 멀티 프로세스 대비 메모리를 적게 사용할 수 있다.

또한, 서블릿은 요청 당 프로세스가 아닌 요청 당 스레드를 사용한다.

따라서 요청 당 스레드(Servlet)가 요청 당 프로세스(CGI)보다 더 효율적이라고 볼 수 있다.

### 왜 전역 변수를 쓰지 말라고 하는 것일까?

### 코드 관점

전역 변수는 스택 프레임에 독립적인 변수이다..(작성 중)

### 멀티 스레드 관점

## 15. UML(Unified Modeling Language)이란?

## 16. 객체지향의 4대 특성에 대해 설명해보자.
