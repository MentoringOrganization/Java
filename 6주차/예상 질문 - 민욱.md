# 💡 (7주차) 자바 예상 질문 정리

# 📜 이전 복습
## 참조 자료형과 기본 자료형의 차이를 설명하라.

### Java는 Call by Value인가? Call by Reference인가? 설명하라.

## Polymorphism에 대해 설명하라.

## 동등성과 동일성에 대해 설명하라.

### equals와 hashCode메서드를 비교하라.

### 왜 두개를 같이 오버라이딩 하라는 말이 있는가?

## 
# 📚 예습
## Transaction이 무엇인지 설명하라
Transaction이란 쪼개져선 안되는 DB연산의 처리 단위이다. A유저가 B유저에게 100만원을 이체하는 상황을 가정해보자. A유저 계좌에서 잔액을 100만원 차감하고 B유저의 계좌에서 잔액을 100만원 늘리는 과정은 하나의 과정이다. 만약 A유저의 계좌에서만 100만원이 빠지고 B유저에게는 100만원이 안 전해져서는 안된다. 만약 그 사이에 버그가 발생한다면, A유저에 100만원이 빠진 연산이 취소되어야한다. 이것은 Transaction이라고 한다.

### Transaction의 중요한 특성인 ACID를 각각 설명하라.
- Atomicity:  쪼개져서는 안되는 하나의 연산단위를 의미한다. 만약 중간에 에러가 나면 Rollback되어야 한다.
- Consistency:  한국어로 일관성을 말한다. transaction이 commit되기 전에 DB에 정해진 RULE을 위반했는지 확인하는 과정을 거치며 만약 정해진 RULE을 위반했다면 RollBack되게 된다. 예를 들어 통장 잔액은 0이상이여야 한다는 constraints가 있다면, 잔액이 -가 되는 연산은 수행되지 않는다.
- Isolation : Transaction은 서로 독립적이여야한다.(격리 되어야 한다.)H에 여러명이 동시에 이체를 한다면, 동시성 문제가 발생할 수 있다. 하나의 자원에 동시에 읽기연산 후 쓰기연산이 진행된다면 데이터가 꼬일 수 있는데 이를 막기위해 Lock이 걸린다. 
- Durability : 한국어로 영존성이라 한다. commit된 transaction은 데이터베이스에 영구적으로 저장된다는 것을 의미한다. DB Crash가 발생하거나 power가 꺼지거나 하는 일이 발생하더라도 commit된 transaction은 DB에 남아있어야 한다.

##  JDBC API가 하는 역할, JDBC Driver가 하는 역할을 설명하여라.
JDBC API란 자바 언어를 이용하여 데이터베이스와 연동할 수 있는 표준화된 API이다. 이를 통해 어떤 데이터베이스를 사용하더라도 동일한 방법으로 데이터베이스와 연동할 수 있다. 반면 JDBC Driver란 JDBC API를 구현한 드라이버를 의미한다. JDBC Driver는 데이터베이스 제조사에서 제공하며 JDBC API를 구현하여 데이터베이스와 연동할 수 있도록 해준다.

### JDBC 프로그램의 전형적인 실행 순서를 말하라.
1. JDBC 드라이버 로딩
2. 데이터베이스 커넥션을 구함.
3. 쿼리 실행을 위한 Statement 객체 생성
4. 쿼리 실행
5. 쿼리 결과 사용
6. Statement 종료
7. 데이터베이스 커넥션 종료.

## Index가 무엇인지 설명하라.
Index란 원하는 자료를 빨리 찾도록 도와주는 자료구조를 말한다. 책 뒤에 흔히 있는 색인을 예로 들 수 있다. 색인에는 사전순으로 정렬된 주요 키워드들이 적혀있으며, 해당 키워드 옆에는 어느 페이지에 등장한 키워드인지 기록되어 있다. 우리는 특정 키워드에 대해서 찾아보고 싶을 때, 색인을 이용해서 등장하는 페이지를 확인하고 바로 접근할 수 있다. 반면, 색인이 없다면 책의 1페이지부터 한장씩 읽어나가며, 어디서 등장해야하는지 찾아야하는데 이는 이전 방법보다 훨씬 많은 시간이 걸린다.

### Ordered Index와 Hash Index를 비교하라
Ordered Index란 주로 B Tree혹은 B+ Tree로 구현된다. 해당 값이 어디에 존재하는지를 tree를 통해 1/n씩 후보군을 줄여가며 탐색할 수 있기 때문에 
O(log N)의 시간복잡도로 원하는 값을 검색할 수 있다. 반면 Hash Index는 이름에서 보듯이 Hash Algorithm을 사용하기 때문에 O(1)의 시간복잡도로 검색을 수행할 수 있다. 하지만 Hash Index는 여러 문제점을 수반하기 때문에 DB구현체에 따라 지원해주는 DB도 있고 지원해주지 않는 DB도 있다.
Hash Index는 단일 검색의 경우 Ordered Index보다 빠른 성능을 보이지만, 범위 검색은 불가능하다. 즉, 범위 검색의 경우 결국 Full-Scan이 수행된다.</br>
반면 Ordered Index의 경우 정렬된 상태로 존재하기 때문에, 범위 검색도 Index를 이용해 빠른 시간에 검색이 가능하다.
뿐만 아니라, Hash Index는 데이터가 삽입될 때, resizing이 발생되는데 resizing이 많은 Overhead를 동반하기 때문에 운영중인 DB에서 resizing이 발생했을 때, 성능문제가 발생할 수 있다.</br>
범위 검색이 아닌 단일 검색만 이뤄질 search key이며, 운영환경에서 삽입 연산이 거의 이뤄지지 않는 제한된 상황에서만 사용하는 것이 좋다. 제한된 상황이란 운영 전에 미리 채워 넣어놓은 데이터이며 추가적인 대량의 데이터 삽입은 예정에 없어야 한다. 또한 그 양이 매우 많아 Hash Index를 사용하는 이점이 있을 때 사용할 수 있을것으로 예상한다. 예를 들어, 시간표 어플에서 전국의 대학교 수업 일정을 크롤링 해놓고 유저에게 제공하는 경우 학기가 끝날 때 까지 추가적인 데이터 삽입예정이 없을 것이며, 대량의 데이터가 있으므로 강의 코드,이름, 교수님의 성함 등으로 검색하는 index에 사용할 수 있어보인다.

### Clustering Index(=primary Index)와 Non-Clustering Index(=secondary Index)를 비교하라.
Clustering Index는 Primary Key혹은 Unique Key를 대상으로 생성된다. Clustering Index는 B Tree(또는 B+, B*)구조를 띄는데 이때 leaf Node가 데이터 그 자체이다. 따라서 Clustering Index는 테이블당 하나만 생성될 수 있다. 일반적으로 대부분의 DB에서 primary Key가 자동으로 Clustering Index로 설정된다.</br>
Non-Clustering Index의 경우 Primary Key나 Unique Key가 아닌 일반 칼럼에도 사용할 수 있다. 마찬가지로 일반적으로 B Tree 계열에서 사용된다. 차이점으로는 leaf Node가 데이터 row를 가리키고 있는 포인터이다. 물리적인 데이터 정렬과는 상관없이 별도로 존재하므로 테이블에 여러개의 Non-Clustering Index가 존재할 수 있다.</br>
Clustering Index는 Non-Clustering Index에 비해 조회 성능이 빠르다. 반면 추가/삭제/수정의 경우 Clustering Index가 더 느리다는 특징이 있다.

### 왜 Clustering Index는 검색 속도가 더 빠를까?
Clustering Index는 Leaf Node가 곧 데이터인 반면, Non-Clustering Index의 경우 Leaf Node는 데이터를 향한 포인터이다. 따라서 후자의 경우 secondary Storage에 접근이 한번 더 필요하다. Secondary Storage의 I/O는 굉장히 많은 시간이 필요한 작업이라 일반적으로 검색 속도가 Clustering Index에 비해 더 느리다.</br>
추가/삭제/수정의 경우 Tree내에서 재 배열이 이루어져야한다. Clustering Index의 경우 많은 데이터를 포함하기 때문에 수정해주어야하는 데이터의 양이 Non-Clustering Index에 비해 많아 속도가 더 느리다.

## B Tree/B+ Tree에 대해서 설명하라
B+ Tree는 B Tree에 몇가지 추가적인 특성이 더해졌다는 의미에서 +가 붙은 자료구조이다. B Tree의 B는 여러가지 설이 있지만 Balanced의 B라고 기억하는 것이 기억하기에 용이하다. 
B Tree는 BST(Binary Search Tree)가 변형된 형태이다. 기존 Binary Search Tree의 경우는 자식을 최대 두개까지만 가질 수 있다. 반면 B Tree는 가질 수 있는 자식의 최대 개수가 3개 이상인 변형된 형태이다. 따라서 BST가 검색할 때, 후보군을 1/2씩 줄여나갈 수 있는 것 처럼 B Tree는 후보군을 1/n씩 줄여나갈 수 있어 굉장히 빠른 검색 속도를 보장한다. 또한 모든 데이터가 정렬된 상태로 저장된다는 특성을 가진다.
B+ Tree는 B트리에서 몇가지 특성이 추가된 자료구조이다.
1. B+ Tree에서는 leaf Node에만 데이터를 저장하고 internal Node에는 key만 저장한다.
2. leaf Node끼리는 Linked List로 연결되어 있다.
leaf Node끼리 Linked List로 연결되어 있다는 특성은 범위검색(where절 안에 >, <, between등의 연산자가 들어가는 경우)때, 해당 LinkedList로 빠르게 탐색하는데 도움을 준다.

※ cf) B Tree의 B는 B Tree의 특성때문에 Balanced의 B라고 추측한다. 하지만 해당 자료구조를 고안한 Bayer의 이름을 따 B라는 설도 있고,
       해당 연구원 속해있던 연구소 Boeing Scientific Research Labs(보잉 과학 연구소)의 B라는 설도 있다. 출처: 위키백과 ㅎ

### B Tree의 조회 성능에 대해 논하라.
B+ Tree의 경우 다른 일반적인 Balanced Tree처럼 $log{N}$의 시간복잡도를 가진다. 상수를 제거하지 않으면 $log{_m}{N}$ 이다. 여기서 m은 몇차 B+ Tree인지를 가리킨다. 해당 m은 시간복잡도에서는 제거되지만 일반적인 BST보다 성능이 훨씬 빨라지는 중요한 요소이기 때문에 언급하였다.

### B Tree의 삽입/삭제 성능에 대해 논하라.
삽입 및 삭제 또한, 삽입해야하는 위치, 삭제해야하는 위치를 찾는데 $log{N}$이 걸리므로 삽입 삭제또한 시간 복잡도가 $log{N}$이다. 단순 시간복잡도로 보면 항상 $log{N}$이지만 오버헤드가 커질 수 있는 형태가 있으므로 언급하겠다.</br></br>
**삽입 worst case**
![image](https://github.com/MentoringOrganization/Java/assets/46997074/e02cc51b-2797-4aef-88c6-76053245da1e)
![image](https://github.com/MentoringOrganization/Java/assets/46997074/261abd33-1b86-4410-b176-c5b35f530335)
![image](https://github.com/MentoringOrganization/Java/assets/46997074/4fd1cd26-9d8a-4c65-9ac8-2f08035eb9bf)
![image](https://github.com/MentoringOrganization/Java/assets/46997074/c82f93d9-22e4-4a87-9731-f5708aa0343f)
위 사진은 3차 B tree에서 40을 추가할 때 발생할 수 있는 worst case가 얼마나 많은 overhead를 부담하게 되는지를 보여준다. 위 사진에서는 level과 크기가 3밖에 안되지만, 그 개수가 많을 수록 더 많은 overhead가 발생할 것이다.

1. 위 케이스에서 처음 40을 추가하려면 50/60 노드에 삽입되어야 한다. 이는 데이터가 정렬되어서 추가되어야하기 때문이다. 하지만 50/60노드는 모두 차있으므로 해당 노드는 분할되어야 한다.
2. 2번째 사진을 보면 40, 60으로 분할되었고 50이 부모 노드로 올라갔다. 하지만 부모 노드 또한 크기가 넘치게 되어 부모 노드또한 분할되어야 한다.
3. 3번째 사진을 보면 30, 70으로 분할되었고 50이 부모 노드로 올라갔다. 하지만 부모 노드 또한 크기가 넘치게 되어 부모 노드또한 분할되어야 한다.
4. 결국 부모 노드또한 7, 50으로 분할되었고 15가 새로운 root Node가 되었다.

이처럼 삽입으로 인해 노드가 넘치게 되면, 모든 leaf Node는 같은 level에 존재해야 한다는 특성을 지키기 위해 노드가 분할되고 부모노드로 하나의 노드가 올라간다. 이것은 연쇄적으로 노드 분할을 일으킬 수 있으며, 이는 B Tree의 삽입연산이 느린 이유이다.

**삭제 worst case**
![image](https://github.com/MentoringOrganization/Java/assets/46997074/b292817f-3256-41b8-8caa-a0bd4f2e4c61)
![image](https://github.com/MentoringOrganization/Java/assets/46997074/f083d8ab-c0dd-4be7-83b2-842eb600dee3)
![image](https://github.com/MentoringOrganization/Java/assets/46997074/e1f5d165-2d51-4ad0-b486-8e6ee0d0872d)
![image](https://github.com/MentoringOrganization/Java/assets/46997074/9b53902d-cd04-4c06-9bd0-892ef4c73221)
위 사진은 5차 B Tree에서 45를 삭제할 때 발생할 수 잇는 worst case가 얼마나 많은 overhead를 부담하게 되는지를 보여준다. 위 사진에서는 level이 3 크기가 5밖에 안되지만, 그 개수가 많을 수록 더 많은 overhead가 발생할 것이다.

1. 45는 rootNode이므로 그냥 삭제될 수는 없다. 삭제는 항상 leaf Node여야 하므로 적절한 값을 rootNode로 올려주고 45를 leaf Node로 옮긴 뒤에 삭제해야 한다.
2. 여기서 적절한 값은 자식 노드중 가장 큰 값이 될 수 있다. 따라서 40이 root Node로 올라오고 45는 삭제된다.
3. 45를 삭제하고 나니 35가 들어있는 node는 key가 1개밖에 없는 node이다. 5차 B Tree의 최소 key의 수는 2이므로 해당 Node는 다른 형재에게 값을 빌려올 수 잇는지 확인한다. 하지만 동생 node도 값을 빌려줄 수 있는 상황이 아니다. 이럴때는 형재 노드와 병합이 이루어진다.
4. 정렬 상태를 유지하기 위해 부모 노드로부터 30을 빌려오고 35가 동생 노드에 합쳐졌다. 하지만 이로인해 부모 노드 또한 key가 1밖에 안남았다. 형재 노드에게 값을 빌릴 수 있는지 확인해보지만, 형재 노드도 값을 빌려올 수 있는 상황이 아니다. 따라서 형재노드와 병합이 이루어진다.
5. 결국 부모로부터 40을 빌려오고, 형재노드와 병합이 이루어저 level이 줄어들었다.

이처럼 값의 삭제가 이루어지면, 노드끼리의 병합이 이루어져야하는 경우가 있다. 또한 이때, 부모로부터 값을 빌려와야 하므로 연쇄적인 노드 병합이 이뤄지곤 한다. 이것은 B Tree의 삭제가 느린 이유이다.

B Tree에서 삽입과 삭제는 시간복잡도로 치면 여전히 $log{N}$ 이다. 하지만 삽입과 삭제에는 많은 overHead가 있으며, 위에서는 3차 5차 B Tree였지만 실제 DB에서는 100차 B Tree와 같이 많은 노드가 존재하며 삽입/삭제 과정은 더 복잡해 진다. 또한, 하나의 테이블에는 여러개의 인덱스가 걸려있으므로 하나의 삽입/삭제가 여러개의 B Tree 재조정을 필요로 한다. 심지어 Clustering Index는 leafNode의 값으로 실제 데이터들을 가지기 때문에 조정해줘야 하는 데이터의 개수가 매우 많다. 이는 무시하기에 너무 큰 OverHead므로 Index를 많이 걸어 놓으면, 삽입/삭제 성능에 많은 영향을 준다는 것을 기억하자.

※ 이미지 출처: https://www.youtube.com/watch?v=H_u28u0usjA&list=PLcXyemr8ZeoREWGhhZi5FZs6cvymjIBVe&index=27

### Index는 무조껀 많이 거는게 능사인가?
Index는 위에서 봤듯이 많은 OverHead를 포함하는 작업이다. 검색 작업의 속도를 매우 올려줄 수 있지만, 삽입/수정/삭제에 대해서 많은 OverHead를 포함한다. 또한 CPU 성능의 OverHead뿐만 아니라 메모리적으로도 많은 메모리 사용을 포함한다. 따라서 최소한의 Index를 적절한 곳에만 걸어주는 것이 바람직 하다.

### BST에 비해 B Tree가 데이터베이스에 더 적합한 자료구조인가?
BST중에서는 AVL이나 Red-Black Tree처럼 Balanced 이진 트리가 존재한다. 해당 이진 트리들은 B Tree에 비해 한번에 줄일 수 있는 후보군이 적어서 B Tree가 여전히 더 빠르다. 하지만 사실 시간 복잡도는 둘 다 $log{N}$ 으로 상당히 검색에 빠른 자료구조이다. B Tree가 BST보다 더 빠른 이유가 단순히 한번에 줄일 수 있는 후보군 수 때문일까? DB에 특성에 중점을 두어 생각해 보자.</br>
Java에서 사용하는 자료구조들은 메모리상에 존재하지만, DB데이터는 Secondary Storage(HDD,SSD)에 존재한다는 점에 중점을 두자. Secondary Storage는 main memory보다 현저하게 느린 속도를 제공한다. 또한 secondary Storage는 읽기 연산을 수행할 때, 중요한 특성이 있는데 바로 Block 단위로 데이터를 읽는다는 것이다.</br>
![image](https://github.com/MentoringOrganization/Java/assets/46997074/fa7ccf0c-3413-4008-8085-8c428947365b)
Blcok은 주변 데이터들도 일반적으로 이어서 사용할 가능성이 높다는 locality에 기초하고 있지만, DB에서 Index를 통해 데이터를 탐색하는 경우, 다음 탐색 지역은 Pointer로 연결된 다음 Node이다. 하지만 Block단위로 읽어오면서, 불 필요한 데이터를 너무 많이 가져온다.
반면 B Tree의 경우 Block단위로 가져올 때, Node의 크기가 커 Block내에는 대부분 필요한 데이터들이 가져와진다. 이는 B Tree가 다른 Balanced Tree보다 DB에 더 적합한 이유이다.

## JDBC 드라이버를 어플리케이션 실행시 로딩하는 것은 어떤 이점을 가져다 주는가?
전통적인 방식에서는 JSP에서 DB와 연결하길 원할 때 마다, JDBC드라이버를 매번 로딩했다. 하지만 해당 방식은 비효율적이다. JDBC 드라이버를 미리 로딩시켜 놓고, DB와의 연결이 필요할 때, 이미 로딩되어있는 드라이버를 사용하는 것이 효율적이라 일반적으로 해당 방식으로 진행한다.

### QFM. 왜 JDBC Driver Pool은 없을까..?
여러 쓰레드에서 동시에 DB접근을 하려할 때, JDBC Driver를 각각의 쓰레드가 사용해야 할 건데 JDBC Driver가 여러개 로딩되어있으면 병렬적으로 사용할 수 있을텐데 왜 JDBC Driver는 하나만 생성하는 걸까?

## Connection Pool에 대해 설명하라.
Java Application에서 DB에 접근하려면 Conection 객체가 필요하다. 필요할 때 마다 매번 Connection 객체를 생성하는 것 보다, Connection 객체를 미리 일정 량 생성해 놓고 요구할 때 마다 이미 생성했던 Connection 객체를 전달하는 것이 더 효율적이다. 미리 생성해놓은 Connection 객체 집합을 Connection Pool이라 부른다.

### Connection Pool의 크기가 너무 작아지면 어떤 일이 발생할 까? Connection Pool의 크기가 너무 커지면 어떤 일이 발생할 까?
Connection Pool의 크기가 너무 커지면, 불필요한 메모리 사용량이 너무 크다는 문제가 있다.
반대로 Connection Pool의 크기가 너무 작아지면 어떤 일이 발생할 지 생각해 보자. 가장 일반적으로 DB에 접근하려는 Thread들은 원하는 Connection을 얻지 못하고 Block되어 있는 시간이 늘어날 것이다. 이는 서버의 성능에 악영향을 끼친다. 하지만 특수한 경우에는 단순 응답 지연현상보다 더 큰 문제를 야기할 수 있다.
일반적인 경우에는 하나의 Thread가 하나의 Connection만 잡는다. 하지만 몇몇 특수한 상황에는 하나의 Thread가 여러 Connection을 요구할 수 있다.
예를 들어 JPA의 id strategy를 GenerationType.AUTO로 설정하거나, 여러 DB구현체 조작이 동시에 필요한 경우가 있을 수 있겠다.
하나의 쓰레드가 2개의 Connection을 필요로 한다고 가정해 보자.



# 📚 추가 질문

## SOP와 CORS가 무엇인가?

### SOP가 필요한 이유가 무엇인가?

### CORS는 왜 브러우저에서만 필요한가?

### preflight 요청이 무엇인가?

### JSONP가 무엇이고 왜 지양되는가?

## CSRF가 무엇이고 관련 보안적으로 발생할 수 있는 시나리오를 설명하라

### CSRF를 방어할 수 있는 수단에는 무엇이 있는가?

### SameSite가 무엇인지 설명하라

## XSS가 무엇인지 설명하라

## HTTPS가 왜 HTTP보다 보안적으로 우수한가?

### HTTPS는 사이트가 신뢰할 수 있다는 것을 보장해준다. 어떻게 그게 가능한가?

### HTTPS는 중간에서 패킷을 탈취하더라도 해독할 수 없도록 해준다 어떻게 그게 가능한가?

### HTTPS에서는 대칭키와 비대칭키가 어떻게 사용되는지 논하라.

### 왜 비대칭키는 컴퓨터에 부담을 주는가?



