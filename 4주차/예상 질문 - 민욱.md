# 💡 (5주차) 자바 예상 질문 정리

# 📜 복습

## 1. 클래스와 객체를 비교하여라.
클래스란 객체를 생성하는 설계도로 이해할 수 있다. 클래스는 Class Loader에 의해 Method Area에 적재된다. Method Area에는 static 멤버, 클래스의 Byte Code가 로딩된다. 해당하는 객체의 인스턴스가 생성될 때, 즉 new 키워드가 호출될 때 Heap영역에 인스턴스가 생성된다. 하나의 클래스에선 일반적으로 여러개의 인스턴스가 생성될 수 있으며 이는 서로 독립적인 관계에 있다. 다만 static member는 객체끼리 공유하므로 Method Area에 생성된다.

## 2. 객체를 생성하려면 new 키워드를 사용한다. Car car = new Car(); 를 호출했을 때, 일어나는 일을 설명하라.
new 키워드를 통해 인스턴스를 생성할 때, 아래 과정을 거친다.
1. 해당 클래스가 Method Area에 로딩되었는지 확인한다.
2. 만약 로딩되지 않았다면 JVM은 JRE라이브러리에서 해당 클래스를 탐색한다.
3. 만약 없다면, CLASS PATH 환경변수에 지정된 폴더에서 해당 클래스를 찾는다.
4. 찾았다면 Method Area로 해당 클래스를 로딩한다.
5. static member에 대한 초기화가 이루어진다.
6. Heap 영역에 해당 인스턴스를 위한 메모리를 할당한다.
7. 명시적 초기화, 초기화 블럭, 생성자 순으로 멤버 변수에 대한 초기화가 이루어진다.

## 3. 변수에는 local Variable, Parameter, Instance Variable, Class Variable이 있다. 해당 변수들의 차이를 설명하라.
local variable이란 {}안에서 선언되는 변수를 말한다. 주로 메서드 내에서 선언되며, 초기화 블럭, 생성자 등 {}안에서 선언되면 모두 local variable이라 부른다. 해당 변수는 Heap영역에서 할당되며 해당 {}가 끝나면 더 이상 접근이 불가능하다.
Parameter는 메서드안에 데이터를 전달하기 위해 사용된다. Stack영역에서 할당되며, 해당 메서드가 끝나면 더 이상 접근이 불가능하다.
Instance Variable은 Heap영역에서 선언되며 인스턴스가 생성될 때, 초기화된다. 해당 인스턴스가 Garbage가 될 때 까지 접근이 가능하다.
Class Variable이란 Method Area에서 선언된다. 해당 클래스가 처음 로딩될 때, 초기화된다. 프로그램이 종료되는 시점까지 접근이 가능하다. (GC의 대상이 아니다.)

### JVM Memory 관점에서도 설명하라.
위에서 설명하였다.

## 4. Byte,short,int는 모두 정수형이다. 어떤 차이가 있는가?
Byte는 1 byte, short는 2byte, int는 4byte로 할당받는 메모리 공간이 다르다.

### 그럼 byte범위의 값만 들어갈 수 있을 땐 byte, short 범위의 값만 들어갈 수 있을 땐 short, int 범위의 값이 들어가야 할 때는 int로 선언하면 될까? 이게 항상 맞는 말인가?
해당 변수들이 연산되기 위해 Stack영역 위에 올라갈 때, Stack에서는 모두 정수형 변수를 위해 4byte를 할당받는다. (long은 8byte이다.)
Stack구조에 저장되기 위해 byte, short와 같은 변수들은 형변환이 이루어 져야한다. 물론 Heap영역, Method Area영역에 저장된 같은 변수는 좀 더 작은 메모리 공간을 가지고 있겠지만, 일반적으로 이것은 형변환의 비효율성을 감수할 정도의 메리트는 없다.
임베디드 개발을 하면서 너무 작은 메모리 공간에서 자바 어플리케이션을 개발하는 것이 아니라면, byte, short보다는 int형으로 선언하는 것이 더 효율적일 것이라 본다.

### Stack공간의 구조를 설명하라.
Stack은 Frame별로 구분된다. 하나의 메서드가 호출되면 하나의 Frame이 Stack에 올라간다.
Frame은 다시 LVA(Local Variable Array), OS(Operand Stack), FD(Frame Data)로 구분된다.

- LVA(Local Varaible Array):
![image](https://user-images.githubusercontent.com/46997074/235572242-0341e6d8-4541-455c-8ddf-264d8595b6fa.png)
int, float, reference 는 1개의 slot을 할당받으며 이는 4byte이다.
double, long은 2개의 slot을 할당받으며 이는 8byte이다.
byte, short, char은 1개의 slot을 할당받으며 이는 4byte이다. 따라서 해당 변수들은 int형으로 변환되어 저장된다.

<br>

- OS(Operand Stack):
Operand Stack이란 지역변수, 매개변수 끼리의 연산의 중간 결과값이 저장되는 영역이다. instruction에 의해 operand stack에 적재되거나 내보내진다.
해당 배열도 word의 배열로 생각하면 된다. 따라서 double, long을 제외하고는 모두 1개의 slot을 가지고 4 Byte이다.
![image](https://user-images.githubusercontent.com/46997074/235572266-1bf76d4d-d057-4f6d-addb-f534d85b4202.png)

<br>

- FD(Frame Data):
frame Data는 constant Pool에 대한 참조, exception table에 대한 정보가 올라간다.

## 5. For문, Enhanced For문, Stream().forEach()문의 성능 차이를 비교하여라.

### Stream은 왜 느린가?

## 6. Process 와 Thread가 무엇인지 설명하라.
Process란 프로그램이 실행되기 위해 메모리공간에 올라간 상태를 말한다. 반면 Thread란 프로세스의 실행 흐름을 Thread라 말한다.
하나의 Process는 여러개의 Thread를 가질 수 있다.
하나의 Process가 여러개의 Thread를 가지면 각각의 thread가 하나의 코어에서 병렬적으로 실행될 수 있어 task를 빨리 끝낼 수 있다는 장점이 있다.
JVM Runtime Area에는 Method Area, Heap Area, Stack Area, PC Register, Native Method Area로 나뉜다.
Method Area, Heap Area의 경우 Thread끼리 공유하는 영역으로 여러 쓰레드가 동시에 접근이 가능하다.
반면, Stack Area, PC Register, Native Method Area의 경우 각각의 Thread가 독립적인 공간을 가진다.

### Process를 여러개 쓰는 것과 Thread를 여러개 쓰는 것이 어떤 차이가 있는가? Thread를 여러개 쓰는게 어떤 장점이 있는가?
위에서 설명 했듯이, Thread는 Method Area, Heap Area와 같은 공간을 공유한다. Process 끼리 데이터를 공유하는 것은 원칙적으로는 금지되어 있어 데이터를 공유하기 위한 수많은 작업들이 추가되어야한다. 반면, Thread는 생성하면 자동으로 공유하는 영역들을 가지고 있어 손쉽게 데이터를 공유할 수 있다는 장점이 있다. 또한 Process를 생성하기 위해선 같은 크기의 메모리공간을 별도로 할당해야하는 반면, Thread는 Stack,PC,Native Method Area에 해당하는 메모리만큼만 새로 할당받으면 되어서 메모리 공간을 아낄 수 있다는 장점도 가진다.

### Thread를 생성하는게 Process를 생성하는 것 보다 왜 빠른가?
위에서 함께 언급하였다.

### Thread가 왜 Process를 생성하는 것보다 메모리를 적게 차지하는가?
위에서 함께 언급하였다.

## 7. Concurrency와 parallel을 비교하라.
Parallel은 여러 쓰레드가 각각 코어를 할당받아 병렬적으로 실행되는 것을 Parallel이라고 하는 반면, Concurrency는 쓰레드가 하나의 코어를 공유하고 차례로 실행되는 것을 Concurrency라고 한다.

### synchronized키워드는 병렬성을 띌때만 사용하면 될까?
동시성 문제는 Parallel하게 실행될 때만 나타나는 것이 아니다. Concurrency하게 실행되는 상황에서도 동시성 문제가 나타날 수 있으므로 synchronized 키워드를 사용하는 것이 좋다.

## 8. multi-thread 왜 쓰는건지 설명하라. 단일 쓰레드에 비해 어떤 장점이 있는가?
단일 쓰레드라면 하나의 프로세스의 task를 처리하는데 하나의 코어만 사용가능 하다. 따라서 해당 업무를 처리하는데 걸리는 시간이 10이라면, 최소 10이라는 시간을 써야하는 반면 쓰레드가 두개고 두개의 코어에서 동시에 병렬적으로 실행될 수 있다면 이론적으로는 5의 시간만에 해당 task를 완료할 수 있다.
하지만 실제로는 쓰레드 끼리의 동기화 작업과 같은 문제로 5보다는 많은 시간이 걸린다.

### multi-thread는 단일 쓰레드보다 항상 빠른가?
multi-thread가 병렬적으로 돌아가는 상황이라면 일반적으로는 single-thread보다 더 빠르다. 하지만, parallel이 아니라 concurrency하게 작동하는 상황이라면 context switch 비용에 의해 그렇지 못할 수도 있다.
예를 들어 크기가 10000인 int 배열의 요소의 합을 구하는 task가 있다고 하자. 단일 쓰레드에서 1 ~ 10000을 loop돌며 모두 구할 것이다. 쓰레드가 2개라면 하나는 1 ~ 5000, 다른 하나는 5001 ~ 10000까지 더한다음 각 쓰레드의 결과 값을 합칠 수도 있다.
만약 concurrency하게 작동하는 상황이라면 context switch 때문에 오히려 2개의 쓰레드가 더 느릴 수도 있다.

### 단일 코어에선 항상 single-thread가 더 빠를까?
File IO가 필요한 task가 있고 해당 IO는 synchronous라고 하자.
해당 IO를 위해 Java Application Thread가 Block이 되어 다른 쓰레드는 실행이 못 될 수도 있다. 반면 여러 쓰레드라면 하나의 쓰레드가 block이 된 동안 나머지 쓰레드가 다른 task를 미리 실행시킬 수 있다. 따라서 단일 코어에선 무조껀 single thread가 더 빠르다는 말은 잘 못 되었다.

## 9. synchronized 키워드가 하는 역할을 설명하라.
synchronized는 메서드앞에 키워드로 사용하거나 synchronized 블럭을 만들어서 사용할 수 있다. 해당 블럭/메서드 안에는 동시에 하나의 thread만 접근 할 수 있어서 Critical Section에 해당하는 영역을 synchronized 키워드를 통해 lock을 걸면 동시성 문제를 해결할 수 있다.

### 어떤 변수나 객체에 여러 쓰레드가 접근하는 경우 항상 synchronized키워드가 필요할까?
동시성 문제는 공유하는 자원에 쓰기 연산이 이루어 질 때, 발생한다. 따라서 여러 쓰레드가 동시에 읽기 연산을 하는 경우는 synchronized 키워드를 사용하지 않아도 된다. synchronized를 하면 다른 thread는 block이 되어 성능에 악영향을 주므로 꼭 필요할 때만 synchronized 키워드를 사용하는 것이 좋다.

### critical Section의 동시성 문제를 해결하는 방법은 synchronized 밖에 방법이 없을까?

## 10. setPriority() 메서드가 하는 역할을 설명하라.
CPU Scheduler는 각자의 알고리즘에 따라 어떤 쓰레드를 다음에 실행할지를 결정한다. 이때, 판별기준중 하나가 쓰레드의 우선순위이다. 개발자는 thread의 우선순위를 결정할 수 있으며, 결정하지 않는다면 default는 5로 되어있다. 우선순위가 높으면 일반적으로 낮은 우선순위의 쓰레드보다 우선적으로 실행된다.

# 📚 예습
## 11. 웹 브라우저에 https://www.naver.com를 입력했을 때, 어떤 일이 발생하여 브라우저에 네이버 창이 뜨는지 과정을 설명하라.

## 12. WS 와 WAS를 비교하여라.

### 정적 자원과 동적 자원을 비교하라.
정적 자원은 항상 똑같은 응답이 발생하는 것이다. Image와 같은 파일은  어떤 파라미터를 넘겨주었는가, 어떤 유저가 요청하였는가와 상관없이 항상 같은 이미지가 전달되곤 한다. 또한 옛날에 주로 쓰이던 정적인 HTML파일들도 정적 자원이지만 요즘은 HTML파일이 정적 자원인 페이지가 잘 없다.
동적 자원이란 어떤 파라미터를 넘겼는지, 누가 요청하였는지에 따라 변하는 데이터를 가지고있을 때, 동적 자원이라 한다. 해당 파라미터나, 요청자에 따라 동적으로 HTML을 생성해서 응답한다.
### 정적 자원은 왜 WS단에서 응답을 주는가?
Client가 요청을 보내면 네트워크를 통해 WS로 도착한다. WS에서는 다시 WAS로 요청을 보내고 WAS는 해당 요청에 응답을 바로 주거나, DB단에 다시 요청을 보낸다.
Client -> WS -> WAS -> DB 순으로 요청이 오는데 정적 자원은 가공없이 바로 응답하면 되기 때문에 WAS까지 가는건 시간적으로 비효율 적이다. WAS까지 가지않고 WS에서 응답을 보낼 수 있다면, 더 빨리 응답할 수 있다.
또한 WAS는 Tomcat위에서 실행되고 있는 Spring Boot와 같은 서비스이다. 해당 Process에 들어오는 요청 하나하나는 결국 process의 자원을 잡아먹는다. WAS에 보내지는 요청을 줄이는 것은 해당 Process의 자원을 아낄 수 있다는 장점이 있다.

## 13. HTTP 요청/응답이 어떻게 구성되어 있는지 설명하라.
HTTP 요청/응답은 header, body, Method, uri(자원의 경로)로 나뉜다.
header에는 메타 데이터가 들어간다. cookie, dataType, content-length, encoding, user-agent 등이 포함된다.
body에는 함께 보내는 데이터들이 주로 들어간다. body는 현대에 와서는 주로 json형태로 데이터를 전달하고 key, value쌍으로 이루어져 있다.
Method에는 GET,POST,PUT,PATCH,DELETE 가 존재한다.
해당 요청의 목적에 따라서 Method를 달리하는 것이 권장된다.(RestFul)
URI는 대상의 도메인 주소, 자원의 경로, path Variable, Query String등이 포함된다.

### HTTP Method에는 어떤 것이 있는지 설명하라.
GET, POST, PUT, PATCH, DELETE가 포함된다. 
Get은 어떤 자원을 요청할 때 사용한다. html파일, image파일, 특정 데이터를 요청할 때 사용된다.
POST는 새로운 것을 생성하길 요청할 때 사용된다. 로그인 토큰, 새로운 유저의 회원가입, 게시글 생성 등에 사용된다.
PUT과 PATCH는 데이터를 수정할 때, 주로 사용된다. PUT은 주로 리소스의 모든것을 업데이트 할 때, 사용되고 PATCH는 주로 리소스의 일부를 업데이트 할 때 사용된다.
DELETE는 데이터를 삭제할 때 사용되곤 한다.

## 14. Tomcat 폴더의 구조를 설명하라.(bin,lib,temp,webapps,logs,work...)

## 15. Response 객체에서 Cache-Control을 no-cache/no-store 로 설정하는 경우가 종종 있다. 이렇게 설정하는 이유가 무엇인가?
Client가 해당 부분을 캐시에 저장하지 않길 원하는 경우에 사용한다.
클라이언트가 해당 응답을 cache에 저장하면 같은 요청을 반복할 때, 서버까지 요청이 들어가지 않고 PC 로컬의 cache를 확인해 데이터를 받아온다. 만약 해당 데이터가 서버단에서 수정되었다면 PC는 옛날 데이터를 받아오게 된다. 이렇게 동작하기를 원하지 않는다면 no-cache/no-store로 설정하여 client가 서버로 재요청을 보내게 강제할 수 있다.
no-cache/no-store모두 클라이언트가 캐시를 저장하지 않게하는 해더지만, no-store는 뒤로가기를 통해 요청을 보냈을 때도 캐시에 저장하지 않는 기능을 수행한다.

## QFM.
## SetPriority를 사용할 일이 있을까?

### 자바단이 아니라 Linux단에서는 Process의 우선순위를 직접 조절할 일이 있을까?

## 멘토님이 말씀하시길 요즘 JSP쓰는 곳은 잘 없어서 JSP를 위해서라기 보단 네트워크를 위해서 해당 책을 공부한다고 했다. JSP는 왜 더 이상 사용되지 않을까?

## 4번 질문에 대한 내 답이 과연 맞을까..?