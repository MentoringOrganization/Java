# 💡 (5주차) 자바 예상 질문 정리

# 📜 이전 복습

## [자바의 신] 3장

## 자바의 경우 코드 작성 → 컴파일 → 실행과정으로 이루어진다. 이 중 컴파일과 실행의 차이에 대해 Java의 전체 프로세스와 관련해서 설명해보자

우선 자바에서 프로그램을 작성하고 실행하는 전체 과정은 다음과 같다.

![image](https://user-images.githubusercontent.com/103405457/235358626-d5bc4c6f-aca4-4394-b518-4c8cfc1d7ae1.png)

1. 소스 코드 작성

자바 프로그램을 작성하기 위해 텍스트 에디터 또는 통합 개발 환경(IDE; Integrated Development Environment)를 사용하여 개발자가 소스 코드를 작성한다. 이때, 이 코드는 '.java' 확장자로 저장된다.

2. **컴파일**

작성한 소스 코드를 컴파일 하여 바이트 코드로 변환한다. 이때, 자바 컴파일러 'javac'를 사용한다.

> ex. 'MyProgram.java'라는 파일 컴파일하기
````
javac MyProgram.java
````
터미널 또는 명령 프롬포트에서 다음 명령을 실행한다.

3. **실행**

컴파일된 바이트 코드를 JVM(Java Virtual Machine)에서 실행한다. 이를 위해 'java' 명령을 사용한다.
> ex.'MyProgram.class' 파일을 실행하기
````
java MyProgram
````
터미널 또는 명령 프롬포트에서 다음 명령을 실행하며, 프로그램이 정상적으로 실행되면 결과가 출력된다.

4. 디버깅 및 수정

프로그램 실행 중 오류나 예외가 발생하면 디버깅 과정을 통해 문제를 파악하고 소스 코드를 수정한다.

그리고 수정된 소스 코드를 다시 컴파일하고 실행하여 오류가 해결되었는지 확인한다.

5. 반복 개발

프로그램의 요구 사항이 충족될 때까지 소스 코드 작성, 컴파일, 실행, 디버깅 및 수정 과정을 반복한다.

---

이때, 컴파일(Compile)과 실행(Run)의 차이는 다음과 같다.

- 컴파일

**자바 소스 코드(.java 파일)를 바이트 코드(.class 파일)로 변환하는 과정이며, 자바 컴파일러(javac)에 의해 수행된다.**

컴파일 과정에서 **문법 오류**, **타입 오류** 등의 **코드 오류**가 발견되면 컴파일러는 오류 메시지를 출력하고 프로세스가 중단된다.

- 실행

**컴파일된 바이트 코드를 실제로 실행하여 프로그램의 결과를 생성하는 과정이며 바이트 코드 실행은 JVM에서 이루어진다.**

실행 과정에서 발생할 수 있는 오류는 **런타임 오류**로, **예외 처리**나 **시스템 리소스 부족** 등의 이유로 발생할 수 있다.


## [자바의 신] 4장

## 다음 코드를 보고 변수들을 설명해보자.

````
public class VariableTypes {
  int iVariable;
  static int cVariable;
  public void method(int parameter) {
    int lVariable;
  }

}
````

<details>
  <summary> 정답 </summary>
  iVariable(인스턴스 변수), cVariable(클래스 변수), lVariable(지역 변수)
</details>

### 지역 변수와 인스턴스 변수의 차이는?

우선, 지역 변수와 인스턴스 변수의 정의는 다음과 같다.

- 지역 변수(Local Variables)

**메소드** 또는 **생성자 내에서 선언**되며, 해당 메소드 또는 생성자의 **실행 도중에서만 사용**할 수 있다.

그리고, **스택(Stack) 메모리에 할당**되며 **메소드 또는 생성자의 실행이 종료**되면 메모리에서 **해제**된다.

또한, **초기값**을 자동으로 할당하지 않기 때문에 사용하기 전에 반드시 **초기화**해야 한다.

- 인스턴스 변수(Instance Variables)

**클래스 내에서 선언**되지만 **메소드 또는 생성자의 범위 바깥에 위치**한다.

그리고, **힙(Heap) 메모리에 할당**되며 객체가 생성될 때마다 각 객체에 대한 인스턴스 변수의 할당이 이루어진다.

이러한 인스턴스 변수는 클래스의 객체가 **GC에 의해 메모리에 해제되기 전**까지 생명 주기를 **유지**한다.

또한, **기본값**이 **자동으로 할당**된다. (ex. 숫자형인 경우 0, 참조형인 경우 null)

즉, 선언 위치와 JVM 메모리에 할당되는 영역, 그리고 초기값의 초기화 유무에 대한 차이가 있다.

추가로, 인스턴스 변수를 생성 및 실행하는 코드는 다음과 같다.
> ex. 학생의 이름과 나이 데이터를 담고 있는 Student 클래스
````
public class Student {
    // 인스턴스 변수 선언
    String name;
    int age;
    
    // 생성자
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
     // 메소드
    public void displayInfo() {
        System.out.println("이름: " + name + ", 나이: " + age);
    }
}
````
> Main 클래스
````
public class StudentMain {
    public static void main(String[] args) {
        // 객체 생성 및 인스턴스 변수 초기화
        Student student1 = new Student("홍길동", 20);
        Student student2 = new Student("이순신", 25);

        // 인스턴스 변수 사용
        student1.displayInfo(); // 출력: 이름: 홍길동, 나이: 20
        student2.displayInfo(); // 출력: 이름: 이순신, 나이: 25
    }
}
````

## float와 double의 차이점에 대해서 설명해보자, 이때 자바에서 어떤 방식으로 소수를 표현하는가?(❗)

### 부동이란?(❗)

### BigInteger를 구현한다면 어떤 방식으로 구현할 수 있을까?(❗)

## [자바의 신] 5장

## 범위가 큰 타입에서 작은 타입으로 변환할 때, 왜 명시적 형 변환을 지양하라고 ? 아래의 코드를 통해 설명해보자
````
public class OperatorCasting {
  public static void main(String[]) {
    OperatorCasting operator=new OperatorCasting();
     operator.casting();
  }
  
  public void casting() {
    ..
  }
  
  public void casting2() {
  short shortValue=256;
  byte byteValue=(byte)shortValue;
  System.out.println(byteValue);
  shortValue=255;
  byteValue=(byte)shortValue;
  System.out.println(byteValue);
  }
}
````

우선, 명시적 형 변환을 수행하는 코드는 byte byteValue=(byte)shortValue;와 byteValue=(byte)shortValue;이다.

이 중 byte byteValue=(byte)shortValue;, 즉 첫 번째 short → byte 계산 과정을 살펴보자.

1. shortValue = 256 (short type)
2. 00000001 00000000 (2진수)
3. (byte)shortValue = 256 (byte type)
4. 앞의 8자리, 즉 1 byte를 버린 100000000 (2진수)
5. 최종 값은 0

즉, 위와 같이 범위가 큰(short) 타입에서 작은 타입(byte)으로의 형 변환에서는 데이터 손실(1 byte)이 발생한다.

따라서 원래의 값을 잃어버리게 되어 원하지 않는 결과를 초래할 수도 있으므로, 데이터 손실 가능성을 생각해서라도 지양하는 것이 좋다.

## [자바의 신] 6장

## switch문에서 왜 반드시 case에 대한 처리가 끝나면 break;를 붙여줘야 할까?

If-ele문은 두 가지 이상의 값을 비교하거나, 단순히 true/false 여부만 확인하고자 할 때 사용한다.

하지만, 하나의 값이 여러 범위에 걸쳐서 비교되어야 할 때 - 즉 하나의 값으로 분기하여 비교할 경우는 swtich문을 사용하는 것이 좋다.

switch문의 기본적인 구조는 다음과 같다.

````
switch(비교대상변수) {
  case 점검값1:
  처리문장1;
  ...
  break;
  case 점검값2:
  ...
  break;
}
````
즉, break문이 없다면 case 조건문이 연달아 실행되어 잘못된 값이 나올 수 있으므로 break문은 case 조건문마다 반드시 넣어주어야 한다.

## [자바의 신] 7장

## 2차원 배열의 크기를 알고 싶을 경우, int twoDim0_0Length=twoDim[0][0].length;와 같이 선언하는 것은 왜 안 될까?

우선, 자바에서 배열의 길이를 알아내는 방법은 **배열이름.length**이다.

이때, 2차원 배열의 경우 위와 같은 방법을 사용하면 1차원 배열의 크기를 알려준다.

따라서 2차원 배열의 크기를 알고 싶다면, 각 1차원 배열에 .length를 붙여야한다.

그렇다면

````
int twoDim0_0Length=twoDim[0][0].length;
````
와 같이 선언하는 것은 왜 안될까?

**왜냐하면 twoDim[0][0]은 배열 객체를 나타내는 것이 아니라 값이 들어있는 공간이기 때문이다.**

즉, twoDim[0][0]은 배열 객체를 나타내는 것이 아니라, int 값을 나타내며 int 값은 배열이 아니므로 .length 속성이 존재하지 않는다.

정리하자면 2차원 배열의 크기를 알고 싶을 때는 **twoDim.length**와 **twoDim[0].length**를 사용해야 한다.

````
twoDim=new int[2][3] // 행 2개, 열 3개를 가진 2차원 배열
twoDim.length // 2차원 배열의 행의 개수(1차원 배열의 개수)
twoDim[0].length // 첫 번째 행의 열의 개수(첫 번째 1차원 배열의 길이)
````

# 📜 이번 복습

## [자바의 신] 15장

## JVM의 구조와 관련해서 Process, Thread란?

### 각각의 영역에 대해 설명해보자

## Runnable 인터페이스를 구현하거나 Thread 클래스를 통해 Thread를 생성하는 것의 차이는?

### run(), start(), sleep(), join(), interrupt(), wait() 메소드에 대해 설명해보자

## 쓰레드의 상태를 설명하고, interrupt() 메소드는 쓰레드의 어떤 상태에 호출된 효과가 발생되며 해당 효과는 무엇인가?

## Lock(Monitor lock)이란?

### Critical section(임계 영역), Spin lock, Mutex, Semaphore란?

## Main Thread란?

## 동시성 처리를 위한 대표적인 세 가지 방법이 있다. 먼저 동시성 처리에 대해 설명한 뒤 세 가지 방법은 무엇이며, 왜 사용할지에 대해 말해보자

## Single Thread와 Multi Thread의 차이는?

### Single Core와 Singel Thread는 같은 뜻일까?

## CPU, RAM, Cache에 대해 설명해보자

### LRU Cache란 무엇이며 어떤 자료구조를 섞어서 사용하는가?

## Singleton 패턴 vs DCL(Double Checked Lock)
