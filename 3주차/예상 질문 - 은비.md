# 💡 (4주차) 자바 예상 질문 정리

# [자바의 신] 17장

## 1. 어노테이션이란 무엇이며 왜 사용하는가?

어노테이션이란 @ 기호를 사용하여 표시하는 프로그래밍 요소에 대한 부가적인 정보를 제공하는 메타데이터의 일종이다.

어노테이션을 사용하면 코드의 가독성을 높이고, 자동화된 문서 생성 및 코드 분석 등에 활용할 수 있다.

- 코드 문서화 : 자바에서 기본적으로 제공하는 javadoc 도구를 사용하여 코드 문서를 생성할 때, 어노테이션을 활용
- 코드 분석 : 어노테이션을 사용하여 코드를 분석, 예시로 @Deprecated로 사용이 권장되지 않는 코드를 표시할 수 있음

### 자바에는 정해져 있는 어노테이션이 3개가 있다. 각각의 이름과 특징에 대해서 설명해보자.

- @Override

해당 메소드가 부모 클래스에 있는 메소드를 Override 했다는 것을 명시적으로 선언할 때 사용한다.

- @Deprecated

클래스나 메소드가 더 이상 사용되지 않음을 명시할 때 사용한다.

- @SupressWarnings

컴파일러 시 나타나는 경고 메시지를 암묵적으로 제외시키기 위해 사용한다.

# [자바의 신] 18장

## 2. 캡슐화와 다형성이란 무엇인가?

- 캡슐화(Encapsulation)

자바에서 캡슐화란 객체의 내부 상태를 보호하고, 외부에서 접근을 제한하여 객체의 무결성을 유지하는 것을 말한다.

클래스 내부의 변수와 메소드를 접근 제어자(Access Modifier)를 통해 캡슐화할 수 있다.

이때, 캡슐화된 멤버 변수는 private으로 선언되며, 이를 외부에서 접근하려면 public으로 선언된 getter와 setter 메소드를 통해 접근해야 한다.

### 객체의 무결성이란?

객체가 올바른 상태를 유지하고 있는지를 나타내는 개념이다.

즉, 객체의 상태는 객체의 멤버 변수(클래스 변수, 인스턴스 변수) 값으로 나타나며, 이 값들이 적절한 범위 내에서 유지되어야만 객체의 무결성이 보장된다.

- 다형성(Polymorphism)

자바에서 다형성이란 같은 이름의 메소드나 연산자를 이용하여 다양한 자료형을 처리할 수 있는 것을 말한다.

자바에서는 다형성을 구현하기 위해 상속과 인터페이스를 사용한다.

즉, 상속을 통해 오버라이딩을 하여 같은 이름의 메소드가 다른 동작을 할 수 있도록 하거나 인터페이스를 다른 클래스에서 구현함으로써, 같은 이름의 메소드를 다양한 방식으로 구현할 수 있도록 한다.

## 3. 참조자료형과 기본 자료형의 차이는?

- 초기화할 때

기본 자료형은 값을 바로 지정하면 되는 반면, 참조 자료형은 일반적으로 new와 생성자를 지정하여 객체를 생성한다.

- 메소드를 호출할 때의 매개 변수

기본 자료형 및 참조 자료형 모두 값을 전달하지만, 참조 자료형 안에 있는 변수들은 참조 주소를 전달한다.

## 4. String 클래스는 더하기 연산을 할 경우 객체가 어떻게 처리되는가?

기존 String 객체는 그대로 유지한 채, 새로운 String 객체를 생성한다.

이때, + 연산자를 반복적으로 사용하는 경우, 새로운 String 객체가 생성될 때마다 문자열을 복사하고 합치는 작업이 수행되어 성능상의 문제가 발생할 수 있다.

따라서 많은 문자열을 연결해야 하는 경우에는 StringBuilder / StringBuffer 클래스를 사용해야 한다.

문자열 연결을 위한 메모리를 미리 할당하고, 문자열을 추가할 때마다 해당 메모리에 직접 삽입하는 방식으로 성능을 향상시키기 때문이다.

# [자바의 신] 26장

## 5. 자바의 IO에는 File 클래스와 Files 클래스가 있다. 두 클래스의 차이는?

- File 클래스

파일 및 디렉토리를 다루는 데 사용되며, 파일과 데릭토리의 경로를 문자열로 다루기 때문에 경로의 유효성을 검사하지 않는다.

또한 파일 조직에 대한 예외 처리가 복잡하며, 객체를 생성하여 데이터를 처리한다.

- Files 클래스

파일 및 디렉토리를 다루는 데 사용되지만, 경로를 Path 객체로 다루기 때문에 유효성과 예외 처리가 가능하다.

또한 Java 7부터 추가된 기능으로서 더욱 강력한 파일 조작 기능을 제공하며, 모든 메소드가 static으로 선언되어 있기 때문에 별도의 객체는 생성할 필요가 없다.

이때, Path 객체는 Files 클래스에서 제공하는 많은 메소드가 Path 객체를 인자로 받기 때문에 함께 사용하기 위해 만들어진 객체이다.

### InputStream과 OutputStream은 무엇이며 왜 사용하는가?

InputStream과 OutputStrean은 자바에서 데이터를 읽고 쓰는 데 사용되는 추상 클래스이다.

- InputStream 클래스

바이트 단위로 데이터를 읽어올 때 사용되며, 자식 클래스로 FileInputStream, ByteArrayInputStream 등이 있다.

- OutputStream 클래스

바이트 단위로 데이터를 쓸 때 사용되며, 자식 클래스로 FileOutputStream, ByteArrayOutputStream 등이 있다.

두 클래스는 입출력 스트림을 다룰 때 매우 유용하며, 다양한 입출력 작업을 수행하기 위해 사용한다.

이때, 입출력 스트림이란 데이터의 소스와 목적지를 추상화한 것으로, 파일 / 네트워크 / 키보드 / 마우스 등 다양한 입출력 장치를 모두 추상화하여 하나의 통일된 인터페이스로 다룰 수 있게 한다.

즉, 파일에서 데이터를 읽거나 파일에 데이터를 쓰는 작업 / 네트워크를 통해 데이터를 전송하거나 수신하는 작업 등을 수행할 수 있다.

### InputStream, OutputStream 클래스와 Reader, Writer 클래스의 차이는?

우선 InputStream과 OutputStream은 바이트(byte) 단위로 데이터를 다루는 반면, Reader 클래스와 Writer 클래스는 자바에서 문자(char) 단위로 데이터를 읽고 쓰는 데 사용되는 클래스로 문자 인코딩과 관련된 작업을 수행할 때 사용한다.

- Reader 클래스

문자 스트림에서 데이터를 읽어오는 추상 클래스이며, 자식 클래스로 FileReader, StringReader 등이 있다.

- Writer 클래스

문자 스트림에 데이터를 쓰는 추상 클래스이며, 자식 클래스로 FileWriter, StringWriter 등이 있다.

이러한 Reader와 Writer 클래스를 사용하여 문자열을 파일에 쓰거나 파일에서 문자열을 읽어오는 작업이 가능하다.

그리고 이때, 인코딩과 관련된 작업을 수행할 수 있기 때문에 다양한 문자 인코딩 방식을 지원한다.

따라서 InputStream과 OutputStream 클래스와 함께 사용되어 매우 효과적인 입출력 작업을 수행할 수 있다.

## 6. synchronous, asynchronous, blocking, non-blocking란?

- synchronous(동기)

요청과 응답이 짝을 이루며, 요청을 보낸 후에 결과를 받을 때까지 대기한다. 즉, 요청한 작업이 완료될 때까지 다른 작업을 수행할 수 없다.

- asynchronous(비동기)

요청과 응답이 짝을 이루지 않으며, 요청을 보낸 후에 결과를 기다리지 않고 다른 작업을 수행할 수 있다. 즉, 요청한 작업이 완료되지 않아도 다른 작업을 수행할 수 있다.

- blocking(차단)

입출력 작업이 완료될 때까지 호출한 쓰레드를 차단한다. 다른 작업을 수행할 수 없으며, 결과를 반환하기 전에는 계속해서 대기한다.

- non-blocking(비차단)

입출력 작업이 완료될 때까지 호출한 쓰레드를 차단하지 않는다. 대신, 바로 결과를 반환하거나 에러를 발생시킨다.

따라서 입출력 작업을 수행할 때는 Blocking I/O 또는 non-Blocking I/O를 선택하여 작업을 수행할 수 있으며 멀티 쓰레드 환경에서는 동기화 방식을 선택하여 작업을 수행할 수 있다.

또한, 네트워크 통신에서도 동기 또는 비동기 방식을 선택하여 통신을 수행할 수 있다. 

# [자바의 신] 27장

## 7. Serializable이란 무엇이며 왜 사용하는가?

Serializable이란 객체를 직렬화(serialization)하는 인터페이스이며 메소드를 가지지 않는 대신, 구현할 때 특별한 메타데이터를 생성하여 직렬화 프로세스에서 사용된다.

이때, 직렬화란 객체를 바이트 스트림으로 변환하여 파일이나 네트워크를 통해 전송하거나 저장하는 작업을 말한다.

Serializable 인터페이스를 사용하는 이유는 다음과 같다.

- 객체의 상태를 저장하고 다른 시간에 재사용할 수 있음
- 객체를 전송하거나 파일에 저장할 수 있음
- 직렬화된 객체는 네트워크를 통해 전송될 때 자동으로 암호화됨
- 직렬화된 객체는 RMI(Remote Method Invocation) 기술과 같은 분산 객체 기술에서 사용됨

### serializableUID란 무엇이며 왜 사용자가 미리 지정하라고 하는 것일까?

Serializable 인터페이스를 구현한 클래스는 직렬화 시에 객체의 상태 정보를 바이트 스트림으로 변환하는데, 이때 객체의 상태 정보뿐만 아니라 해당 클래스의 메타데이터도 함께 직렬화된다.

이 메타데이터에는 serializableUID 속성이 포함되며, 직렬화 시에 버전 관리를 위한 식별자 역할을 한다.

따라서 serializableUID는 해당 클래스의 변경사항이 발생할 때마다 새로운 값을 할당하여 버전 관리를 수행하게 된다.

이때 사용자가 미리 명시해주지 않는다면 자바 컴파일러가 기본 serializableUID 값을 자동으로 할당하는데, 클래스가 변경될 때마다 serializableUID 값이 변경되므로 역직렬화 시 문제가 생길 수 있다.

### transient란?

자바에서 직렬화(serialization)을 수행할 때, 특정 필드를 제외하고 직렬화 대상에서 제외하고자 할 때 사용하는 키워드이다.

일반적으로 직렬화 대상에 모든 필드를 포함하면서 객체를 직렬화 하지만, 객체의 특정 필드(ex. 비밀번호)를 제외하고자 할 때 사용한다.

즉, 사용 시 해당 필드의 값은 직렬화되지 않고, 객체를 역직렬화할 때 해당 필드는 기본값으로 초기화된다.

객체의 필드에만 사용될 수 있으며, static이나 final 필드에는 사용할 수 없다. 또한 반드시 Serializable 인터페이스를 구현한 클래스에서만 사용할 수 있다.

## 8. 자바 NIO란 무엇이며, 스트림과 채널 및 버퍼의 차이는 무엇인가?

NIO(Non-blocking I/O)는 자바에서 제공하는 I/O 패키지로, 기존의 I/O(java.io)보다 더욱 빠른 입출력을 제공하며 비동기(non-blocking) 입출력을 지원한다.

기존의 I/O 패키지에서는 스트림(stream)과 같은 클래스를 사용하여 입출력을 수행하는 반면 NIO에서는 채널(channel)과 버퍼(buffer)를 사용하여 입출력을 수행(= 바이트 단위로 입출력 작업을 수행하지 않음)한다.

이때, 스트림은 단반향적인 입출력 방식으로 입력 스트림과 출력 스트림이 각각 별도로 존재한다.

반면 채널은 양방향 입출력이 가능한 객체로서 입출력을 모두 수행할 수 있고, 버퍼는 채널과 데이터를 주고받는 객체로 데이터를 쓰거나 읽는 동작을 버퍼 단위로 수행한다.

즉, 채널은 비동기 입출력을 지원하여 입출력 작업이 완료될 때까지 블로킹 되지 않는다는 장점이 있다.

# [자바의 신] 28장

## 9. TCP/UDP란?

TCP(Transmission Control Protocol)와 UDP(User Datagram Protocol)는 인터넷 프로토콜 스택의 전송 계층(Transport Layer)에서 사용되는 프로토콜이다.

TCP는 신뢰성이 높은 연결 지향적인 프로토콜로, 데이터 전송의 안전성을 보장한다. 이때, 데이터 전송을 위해 연결 설정(3-way handshake)를 수행하며, 데이터의 전송 순서와 손실 여부를 확인하고 재전송을 수행한다.

반면 UDP는 비연결성이며 신뢰성이 낮은 프로토콜로, 데이터 전송의 속도와 대역폭 사용량을 최소화할 수 있다. 이때, 데이터 전송을 위해 연결 설정 과정이 필요하지 않으며, 데이터 전송 순서와 손실 여부를 확인하지 않는다.

따라서 TCP는 대용량 데이터 전송, 원격 접속, 이메일 등에 많이 사용되며 UDP는 게임, 스트리밍 등에서 사용된다.

# [자바의 신] 21장

## 10. 제네릭은 무엇이며 왜 사용하는가?

제네릭은 클래스 또는 메소드를 작성할 때 사용하는 개념이며, 클래스 또는 메소드의 타입에 대한 제약을 줄이고 타입 안정성을 보장하기 위해 사용한다.

즉, 제네릭을 사용하면 클래스나 메소드에 대한 타입을 미리 선언함으로써 타입 안정성을 보장할 수 있고 코드의 가독성을 높이며 유지보수를 쉽게 만들어 준다.

### 제네릭 타입 중 wildcard는 무엇이며 왜 사용하는가?

어떤 타입이든 상관 없다는 뜻이며, 제네릭 클래스나 메소드를 작성할 때 타입 매개변수를 알 수 없는 경우에 사용한다.

# [자바의 신] 22 ~ 24장

## 11. Collection이란 무엇이며 왜 사용하는가?

Collection이란 여러 개의 데이터를 저장하고 관리하는 인터페이스이다. Collection 인터페이스를 구현한 클래스들은 데이터를 쉽게 추가, 삭제, 검색 등의 작업을 사용할 수 있고, 여러 데이터를 관리하기에 용이하기 때문에 많이 사용한다.

## 12. List란?

List란 순서가 있는 데이터의 모음을 저장하고, 관리하는 데 사용한다. 또한 데이터의 중복을 허용하며, 각 데이터에는 인덱스가 지정되어 있다.

즉, 인덱스를 사용하여 데이터를 검색하거나 수정할 수 있고, 데이터의 순서를 유지하기 때문에 데이터를 순회하거나 정렬하는 데 유용하다. 

따라서 데이터의 추가나 삭제가 빈번하게 일어나는 경우 LinkedList를 사용하는 것이 좋다.

### ArrayList vs LinkedList

ArrayList는 내부적으로 배열을 사용하여 데이터를 저장하며, 데이터의 추가나 삭제시에는 배열의 크기를 변경하고 데이터를 복사해야 하므로 속도가 느릴 수 있다.

하지만, 데이터 인덱스를 사용하여 접근할 때는 O(1)의 시간 복잡도를 가지므로 빠른 검색이 가능하다. 또한, 데이터의 순서를 유지하기 때문에 정렬이나 순회에 용이하다.

반면 LinkedList는 내부적으로 노드와 링크로 구성된 리스트를 사용하여 데이터를 저장하며, 데이터의 추가나 삭제 시에 노드의 링크만 변경하면 되므로 속도가 빠르다.

하지만, 데이터 인덱스를 사용하여 접근할 때는 O(n)의 시간 복잡도를 가지므로 느린 검색이 가능하다. 또한, 데이터의 순서를 유지하기 때문에 정렬이나 순회에는 용이하지만 ArrayList에 비해 메모리 사용량이 더 많다.

따라서 데이터의 **추가**나 **삭제**가 빈번하게 일어나는 경우 LinkedList를 사용하는 것이 좋고, 데이터의 **검색**이 많이 필요한 경우 ArrayList를 사용하는 것이 좋다.

## 13. Set, Map이란 무엇인가?

Set은 순서가 없는 데이터의 모음을 저장하며, 데이터의 중복을 허용하지 않는다. 따라서 중복된 데이터를 저장하지 않아야 하는 경우에 유용하다.

Map은 키와 값으로 이루어진 데이터의 모음을 저장하며, 각 키는 유일해야 한다. 따라서 키를 사용하여 값을 검색하거나 수정할 때 유용하다.

### HashSet vs TreeSet vs LinkedHashSet

HashSet이란 내부적으로 해시테이블을 사용하여 데이터를 저장한다. 데이터를 검색하거나 추가, 삭제할 때 상수 시간(O(1))에 처리된다. 하지만, 데이터의 순서를 보장하지 않는다.

TreeSet은 내부적으로 이진 검색 트리를 사용하여 데이터를 저장하고, 데이터를 정렬된 순서로 유지하며 검색, 추가, 삭제 시에는 O(log n)의 시간 복잡도를 가진다.

LinkedHashSet은 내부적으로 이중 연결 리스트와 해시테이블을 사용하여 데이터를 저장한다. 데이터의 추가, 삭제 시에는 HashSet과 동일한 O(1)의 시간 복잡도를 가지며, 데이터의 순서를 유지한다.

따라서 데이터의 순서를 유지하고 검색 속도가 빠른 것이 필요하다면 LinkedHashSet을 사용하는 것이 좋으며, 데이터의 추가와 삭제가 빈번하게 일어나는 경우에는 HashSet이 성능이 좋고, 데이터의 정렬이 필요한 경우에는 TreeSet을 사용하는 것이 좋다.

### HashMap vs HashTable

HashMap은 내부적으로 해시테이블을 사용하여 데이터를 저장한다. 데이터의 검색, 추가, 삭제 등의 작업을 빠르게 처리할 수 있지만 동시성 처리를 지원하지 않아 멀티 스레드 환경에서 안전하지 않다.

HashTable이란 내부적으로 해시테이블을 사용하여 데이터를 저장한다. HashMap과 동일한 해시 함수를 사용하지만, 모든 메소드에 대해 동기화 처리가 되어 있어 멀티 스레드 환경에서 안전하다. 하지만, 동기화 처리로 인해 성능이 떨어질 수 있다.

따라서 멀티 스레드 환경에서 안전한 데이터의 처리가 필요하다면 HashTable을 사용하는 것이 좋고, 단일 스레드 환경이거나 동기화 처리가 필요하지 않은 경우에는 HashMap을 사용하는 것이 성능상 좋다.

## 14. 컬렉션의 각 시간복잡도에 대해 설명해보자.

# [자바의 신] 25장

## 15. Process, Thread란 무엇인가?

### JVM의 구조와 관련해서 Process, Thread를 설명해보자.

## 16. Context switching이란 무엇이며 왜 발생하는가? 예시를 설명해보자.

## 17. Syncronized를 왜 사용하며 사용하는 방법 2가지는 어떤 것인가?

## 18. Mutex, Spin Lock이란?

## 19. 다음 코드를 보고, 스레드는 총 몇 개이며 상태가 어떻게 변화하는지 설명해보자.
![image](https://user-images.githubusercontent.com/103405457/234030944-ea1e13e3-ed63-4fb8-bb61-58c30c027f86.png)
![image](https://user-images.githubusercontent.com/103405457/234031022-b7048106-5a4a-4c06-8784-6b1177d70ed4.png)

## 20. 위 코드를 보면 interrupt()라는 메소드가 있다. interrupt() 메소드를 호출하면 해당 쓰레드는 어떤 상태에 있을 때, interrupt() 메소드가 호출된 효과가 발생하는가?

### sleep(), join(), wait() 메소드에 대해 설명해보자.

